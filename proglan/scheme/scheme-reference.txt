encoding: utf-8

Кратък справочник по елементи на езика Scheme
=============================================

За по-пълна и подробна информация следва да се използва описанието на езика
и на стандартните библиотеки към него на адрес

        https://r6rs.org

или книгата „The Scheme programming language“, 4-то изд., достъпна на адрес

        https://scheme.com/tspl4.
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––


               Легенда за типовете на аргументите
               ----------------------------------

               n          цяло число
               k          точно неотрицателно цяло число
               x y        реално число
               z w        комплексно число
               c          литера (буква или др.)
               s          низ
               i j        символ
               p          двойка
               os         списък
               v          вектор
               b          байтвектор
               f g h      функция (процедура)
               f?         функция-предикат
               o u r      каква да е стойност

общи действия със стойности
–––––––––––––––––––––––––––
        ––проверки за тип––
(number? o)             --> число?
(boolean? o)            --> булево?
(char? o)               --> литера?
(string? o)             --> низ?
(symbol? o)             --> символ?
(null? o)               --> празен списък?
(pair? o)               --> двойка?
(list? o)               --> (истински) списък?
(vector? o)             --> вектор #()?
(bytevector? o)         --> байтвектор (#vu8(…))?
(record? o)             --> смес от не непрозрачен тип?
(procedure? o)          --> процедура?
        ––сравнения––
(eqv? o u)              --> „почти идентичност“
(eq? o u)               --> по-строго (различава повече от eqv?)
(equal? o u)            --> рекурсивно сравняване по структурата
        ––преобразуване––
(not o)                 --> #t, ако o е #f, иначе #f
        ––изменяне––
(set! i o)              --> присвояване
        ––псевдопресмятания––
(quote o) 'o             --> стойността o (потискане на пресмятането)
(quasiquote o) `o        --> „почти“ quote, с изключение на частите с , и ,@
(unquote o) ,o           --> пресмятане в контекст на quasiquote
(unquote-splicing o) ,@o --> като unquote, но списъкът-резултат се разтваря

действия с числа
––––––––––––––––
        ––основни аритметични действия––
(+ …)                   --> сбор
(* …)                   --> произведение
(- …)                   --> разлика или обратно по знак
(/ …)                   --> частно или реципрочно
(abs x)                 --> абсолютна стойност
(sqrt x)                --> квадратен корен
(exact-integer-sqrt k)  --> кв. корен от цяло число и съотв. остатък (values)
        ––проверки за стойност––
(finite? x)             --> не нечисло и не безкрайно?
(nan? x)                --> нечисло?
(infinite? x)           --> безкрайно?
(zero? x)               --> нула?
(positive? x)           --> положително?
(negative? x)           --> отрицателно?
(even? n) (odd? n)      --> четно? нечетно?
        ––проверки за вид––
(exact? z)              --> точно (цяло или нецяло, вкл. комплексно)?
(inexact? z)            --> неточно?
(complex? z)            --> комплексно?
(real? o)               --> некомплексно?
(rational? o)           --> нецяло и некомплексно? (но не непременно точно)
(integer? o)            --> цяло?
(real-valued? o)        --> вкл. за NaN и за комплексно с имагинерна част 0
(rational-valued? o)    --> вкл. за комплексни с имагинерна част 0
(integer-valued? o)     --> вкл. за цели дробни, реални и комплексни
        ––сравнения и подредба––
(= …)                   --> равни?
(< …) (> …)             --> строго монотонна редица?
(<= …) (>= …)           --> нестрого монотонна редица?
(min …) (max …)         --> минимум и максимум
        ––закръгляния––
(floor x) (ceiling x)   --> закръгляне надолу и нагоре
(truncate x)            --> закръгляне с отсичане
(round x)               --> закръгляне до най-близко
(rationalize x y)       --> приближение на x с точност y
        ––целочислена и дробна аритметика––
(numerator x)           --> числител
(denominator x)         --> знаменател
(div x y) (mod x y)     --> \ остатъкът е неотрицателен
(div-and-mod x y)       --> /
(div0 x y) (mod0 x y)   --> \ абс. стойност на остатъка не надминава y/2
(div0-and-mod0 x y)     --> /
(quotient x y)          --> частно със закр. към 0 от делене на цели числа
(remainder x y)         --> остатък от делене на цели числа като при truncate
(modulo x y)            --> остатък от делене на цели числа като при floor
(gcd x …) (lcm x …)     --> н.о.д. и н.о.к.
        ––действия с комплексни числа––
(make-rectangular x y)  --> комплексно по реална и имагинерна части
(make-polar x y)        --> комплексно по полярни координати
(real-part z)           --> реална част на комплексно
(imag-part z)           --> имагинерна част на комплексно
(magnitude z)           --> модул на комплексно
(angle z)               --> аргумент на комплексно
        ––разни––
(exp z) (expt z w)      --> e на степен z и z на степен w
(log z) (log z w)       --> логаритъм при основа e и w
(sin z) (cos z) (tan z) --> основните тригонометрични функции
(asin z) (acos z)       --> обратни тригонометрични функции
(atan z) (atan x y)     --> ---- || ----

действия с литерни стойности
––––––––––––––––––––––––––––
        ––сравнения и подредба––
(char=? c …)            --> равни?
(char<? c …)            --> възходяща редица?
(char>? c …)            --> низходяща редица?
(char<=? c …)           --> нестрого възходяща редица?
(char>=? c …)           --> нестрого низходяща редица?
(char-ci=? c …)         --> \
(char-ci<? c …)         -->  | варианти, пренебрегващи разликата
(char-ci>? c …)         -->  | между малки и големи букви
(char-ci<=? c …)        -->  |
(char-ci>=? c …)        --> /
        ––проверка––
(char-whitespace? c)    --> празно (шпация и др.)?
(char-numeric? c)       --> цифра?
(char-alphabetic? c)    --> буква?
(char-upper-case? c)    --> главна буква?
(char-lower-case? c)    --> малка буква?
        ––преобразуване––
(char-upcase c)         --> главна буква
(char-downcase c)       --> малка буква

действия с низове
–––––––––––––––––
        ––образуване––
(make-string k)         --> неинициализиран низ с дължина k
(make-string k c)       --> като по-горе, но с членове, равни на c
(string-copy s)         --> копие на низ
(string c …)            --> низ от посочени литери
        ––сравнения и подредба––
(string=? s …)          --> равни?
(string<? s …)          --> (лексикографски) възходяща редица?
(string>? s …)          --> низходяща редица?
(string<=? s …)         --> нестрого възходяща редица?
(string>=? s …)         --> нестрого низходяща редица?
(string-ci=? s …)       --> \
(string-ci<? s …)       -->  | варианти, пренебрегващи разликата
(string-ci>? s …)       -->  | между малки и големи букви
(string-ci<=? s …)      -->  |
(string-ci>=? s …)      --> /
        ––данни за низа––
(string-length s)       --> дължина
(string-ref s k)        --> член на низ по пореден номер
(substring s k0 kn)     --> подниз на s от номер k0 до (но без) kn
(string-append s …)     --> сливане на низове
(string-for-each f s …) --> подобно на for-each
        ––преобразуване––
(string-upcase s)       --> главни букви
(string-downcase s)     --> малки букви
(string-set! s k c)     --> промяна на член k на низ
(string-fill! s c)      --> промяна на всички членове на низ

действия със символни стойности
–––––––––––––––––––––––––––––––
(symbol=? i …)          --> равни?

действия с двойки и списъци
–––––––––––––––––––––––––––
        ––образуване––
(cons o u)              --> двойката (o . u)
(list o …)              --> образуване на списък по посочени членове
(cons* o …)             --> прилагане на cons отдясно наляво
(append os …)           --> сливане на списъци
(reverse os)            --> обърнат списък
(list-sort f? os)       --> устойчиво подреждане според f? със смисъла на <
        ––части на и данни за списък––
(car p) (cdr p)         --> първи и втори член на двойка
(caar p) (cadr p) …     --> композиции на car и cdr, до 4 броя
(list-ref os k)         --> член на списък по номер
(list-tail os k)        --> остатък на списък (вкл. неистински) по номер
(length os)             --> дължина на списък
        ––извличане на части по признак––
(find f? os)            --> #f или първият член, за който f? не е #f
(filter f? os)          --> списък от членовете на os, за които f? не е #f
(partition f? os)       --> два списъка (values)
(exists f? os …)        --> последният резултат от f? или първият не #f
 ,––––––––––––––––––––– --> подсписък с начало търсена стойност или #f
 |       ,––––––––––––– --> двойка от асоциативен списък или #f
 |       |       ,––––– --> като filter с обратен смисъл
memq    assq   remq   –– сравняване чрез eq?
memv    assv   remv   –– сравняване чрез eqv?
member  assoc  remove –– сравняване чрез equal?
memp    assp   remp   –– сравняване чрез изричен предикат
        ––обхождане––
(map f os …)            --> почленно преобразуване, дава нов списък
(for-each f os …)       --> почленно изпълнение, не дава стойност
(for-all f? os …)       --> #f или резултата от последното прилагане на f?
(fold-left f u os …)    --> обхождане (–>) с натрупване
(fold-right f u os …)   --> обхождане (<–) с натрупване
        ––изменяне––
(set-car! p o)          --> присвояване на първия член на двойка
(set-cdr! p o)          --> присвояване на втория член на двойка

действия с вектори
––––––––––––––––––
        ––образуване, дължина и членове––
(make-vector k)         --> неинициализиран вектор с дължина k
(make-vector k o)       --> като по-горе, но с членове, равни на o
(vector c …)            --> вектор по посочени литери
(vector-sort f? os)     --> устойчиво подреждане според f? със смисъла на <
(vector-length v)       --> дължина на вектор
(vector-ref v k)        --> член на вектор по пореден номер
        ––обхождане––
(vector-map f v …)      --> подобно на map
(vector-for-each f v …) --> подобно на for-each
        ––изменяне––
(vector-set! v k o)     --> промяна на член k на вектор
(vector-fill! v o)      --> промяна на всички членове на вектор

действия с байтвектори
––––––––––––––––––––––
        ––образуване, дължина и членове––
(make-bytevector k)     --> неинициализиран байтвектор с дължина k
(make-bytevector k n)   --> както по-горе, но с членове, равни на n
(bytevector-length v)   --> дължина на вектор
(bytevector-u8-ref b k) --> член k на b като число без знак
(bytevector-s8-ref b k) --> член k на b като число със знак
        ––сравняване––
(bytevector=? b1 v2)    --> равни?
        ––изменяне––
(bytevector-u8-set! b k n)       --> сменя член k на b като число без знак
(bytevector-s8-set! b k n)       --> сменя член k на b като число със знак
(bytevector-fill! b n)           --> промяна на всички членове
(bytevector-copy! bs ks bt kt k) --> копира k байта от bs@ks в bt@kt

преобразуване на стойности по вид
–––––––––––––––––––––––––––––––––
(inexact z)              --> получаване на неточно число
(exact z)                --> получаване на точно число
(integer->char k)        --> кодът на литера
(char->integer c)        --> литера по зададен код
(number->string z)       --> получаване на запис (низ) за число
(number->string z k)     --> като по-горе, но с основа k
(number->string z k x)   --> като по-горе, но с точност x
(string->number s)       --> прочитане на число от низ (или #f)
(string->number s k)     --> като по-горе, но с основа k
(string->symbol s)       --> получаване на символ от низ
(symbol->string i)       --> получаване на низ от символ
(string->list s)         --> списък от литерите на низ
(list->string cs)        --> низ по списък от литери
(vector->list v)         --> списък от членовете на вектор
(list->vector os)        --> вектор по списък от членове
(bytevector->u8-list b)  --> списък от членовете на байтвектор
(u8-list->bytevector os) --> байтвектор по списък от членове

смеси („структури“, „записи“)
–––––––––––––––––––––––––––––
(define-record-type i <клаузи>)
    Създава тип смес с име i.  Всяка клауза има вида
        (parent …) | (fields …) | (sealed …) | (opaque …).
    Всички клаузи освен fields може да отсъстват.  Последните два вида се
    задават с булеви стойности.  Всяко име j на член (поле) във fields се
    задава или непосредствено, или с (mutable j).
    Подразбира се основен (без родител), наследяем (не sealed) тип, с видими
    (не opaque) и неизменяеми (не mutable) членове, с имена на конструктор
    make-i и на предикат-различител i? (образувани по името i на типа).
    Може вместо само i да се зададе списък от три изрично зададени имена:
    на типа, на конструктора и на предиката за него.
    Конструкторът е процедура с параметри, отговарящи на членовете; ако има
    родител, първите параметри са за неговите членове.
    За всеки член j се подразбират неизменяемост и имена на доставчик i-j
    и на изменител i-j-set!.  Доставчикът има параметър стойност-смес, а
    изменителят – параметри стойност-смес и стойност-член

условно изпълнение и условен избор
––––––––––––––––––––––––––––––––––
(if o u)                --> условно изпълнение
(when o u …)            --> (if o (begin u …))
(unless o u …)          --> (if (not o) (begin u …))
(if o u r)              --> условно разклоняване в две посоки
(cond                   --> \
  (o …)                 -->  | разклоняване (пресмята последователно всяко o
  …                     -->  | и за първото не #f – съответните команди)
  (else …))             --> /
(case o                 --> \
  ((u …) …)             -->  | сравнява o последователно с всяко u
  …                     -->  | и за равно изпълнява съответните команди
  (else …))             --> /
(or o …)                --> първото не #f, ако има такова, иначе #f
(and o …)               --> последното, ако всички са не #f, иначе #f

именувани стойности (глобални и локални)
––––––––––––––––––––––––––––––––––––––––
(define i …)            --> свързване на име със стойност
(define i)              --> свързване на име с неуточнена стойност

изрази с локално определени в тях променливи
––––––––––––––––––––––––––––––––––––––––––––
(let ((i o) …) …)       --> пресмятане с локалноопределени имена
(let* ((i o) …) …)      --> като вложени let – последователни свързвания
(letrec ((i o) …) …)    --> като let, но с взаимно (и само-) рекурентни св-я
(letrec* ((i o) …) …)   --> като letrec, но с последователни свързвания
(let i ((j o) …) …)     --> като let, но i е име на функцията с парам. j …
(let-values ((…) …) …)  --> като let, но с множествени стойности (values)
(let*-values ((…) …) …) --> спрямо let-values е както let* към let
(в r6rs са отменени letrec-values и letrec*-values)

определяне на функции
–––––––––––––––––––––
        ––безименни функции-изрази––
(lambda (i …) …)        --> функция с определен брой аргументи
(lambda i …)            --> функция с произволен брой аргументи
(lambda (i … . j) …)    --> функция с определен или по-голям брой аргументи
(case-lambda            --> \  аргументите на повикването се сравняват
  (u-par …)             -->  | последователно с u-par-те
  …)                    --> /  и се изпълнява тялото на съответната клауза
        ––именувани функции (глобални и локални)––
(define (i j …) …)      --> функция с определен брой аргументи
(define (i . j) …)      --> функция с произволен брой аргументи
(define (i … . j) …)    --> функция с определен или по-голям брой аргументи

множествени стойности
–––––––––––––––––––––
(values o …)            --> образува множествен резултат
(call-with-values f g)  --> повиква f без аргументи, после g с аргументи
                            множествения резултат на f

косвено пресмятане
––––––––––––––––––
(apply f … os)          --> прилага функция към поотделно и в списък зададени
                            аргументи
(eval o)                --> пресмята като израз стойността на o
(call/cc f)             --> повиква f с аргумент текущото продължение fc;
                            повикване на fc води до връщане в продължението
(dynamic-wind f g h)    --> ако не се избира изрично продължение с call/cc, равнозначно
                            на повикване на f, g и h в този ред, всяка без аргументи;
                            ако някое g се напусне извънредно, изпълняват се всички h
                            на напускания контекст и после всички f на новия активиран
(delay …)               --> дава стойност „отложено пресмятане“
(force …)               --> пресмята отложена стойност

изключителни ситуации (exceptions)
––––––––––––––––––––––––––––––––––
        ––пресмятане под надзор (на реактор на И)––
(with-exception-handler h f) --> повиква без аргументи f под надзора на
                             --> едноаргументна h (аргументът е събитието)
(guard (i               --> \  пресмята последната част под надзора на
  (o …)                 -->  | предходната; ако се възбуди И, съответното
  …                     -->  | събитие става стойност на i и клаузите се
  (else …))             -->  | пресмятат като в cond; ако никоя клауза не
  …)                    --> /  сработва, възбужда се наново същото И
        ––видове събития––
&condition              --> базов тип на събитията
&message                --> „описателно“ С, подтип на &condition
&warning                --> „предупреждение“, подтип на &condition
&serious                --> „грешка“, подтип на &condition
&error                  --> „грешка“, подтип на &serious
&violation              --> „нарушение“, подтип на &serious, има няколко подтипа
        ––действия със събития––
(make-message-condition? o) --> \
(make-warning)              -->  |
(make-serious-condition)    -->  | конструктори за С
(make-error)                -->  |
(make-violation)            --> /
(condition-message oc)  --> стойността на описателното С oc, „съобщението“
(condition? o)          --> \
(message-condition? o)  -->  |
(warning? o)            -->  | проверки за С – изобщо и по вид
(serious-condition? o)  -->  |
(error? o)              -->  |
(violation? o)          --> /
        ––възбуждане на И (пораждане на С)––
(raise-continuable o)   --> възбужда „поправимо“ И – реакторът дава стойността
                        --> на повикването
(raise o)               --> възбужда „непоправимо“ И – работата на реактора
                        --> завършва с ново И
(assert o)              --> стойността на o, ако тя не е #f, иначе възбужда
                            „непоправимо“ И (наред с др. и описателно)
(error ow om)           --> възбужда И с типове &error, &message и др.; ow посочва
                        --> източника на И (where), но може да бъде #f; om задава
                        --> „съобщението“

допълнителни средства
–––––––––––––––––––––
(begin o …)             --> последователно изпълнение/пресмятане
(do                     --> | команда за цикъл от общ вид
  ((i x-init x-step) …) --> | инициализации и изрази за следващи стойности
  (o-until              --> | предусловие, посочва кога се завършва
    …)                  --> | епилог
  …)                    --> | тяло

вход-изход през стандартните канали (вкл. чрез изрично цитиране)
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
        ––вход––
(eof-object)              --> стойността „край на файл“
(eof-object? o)           --> o е „край на файл“?
(standard-input-port)     --> дава нов двоичен входен порт, съединен със stdin
(current-input-port)      --> текущият стандартен текстов входен порт
(get-u8 o)                --> чете октет или „край на файл“ от двоичен порт o
(read-char)               --> чете литера или стойността „край на файл“
(get-string-n o k)        --> чете низ от >0, ≤k литери или „край на файл“ от
                              текстов порт o
(get-string-n! o s ks kn) --> чете в низ >0, ≤kn литери от текстов порт o и дава
                              броя им или „край на файл“
(get-string-all o)        --> чете съдържанието на файл от текстов порт o и дава
                              низ или „край на файл“
(get-line o)              --> чете ред (низ) от текстов порт o или „край на файл“
        ––изход––
(standard-output-port)  --> дава нов двоичен изходен порт, съединен със stdout
(standard-error-port)   --> дава нов двоичен изходен порт, съединен със stderr
(current-output-port)   --> текущият стандартен текстов изходен порт
(current-error-port)    --> текущият стандартен порт за съобщения за грешки
(put-u8 o c)            --> записва октет в двоичен порт o
(write-char c)          --> записва литера на стандартния текстов изходен порт
(display o)             --> записва o на стандартния текстов изходен порт
(newline)               --> като (write-char #\linefeed)

взаимодействие с о.с.
–––––––––––––––––––––
(command-line)          --> дава списък от низове – аргументите на командния ред
(exit) (exit o)         --> завършва програмата и евентуално предава на о.с. признак
