Кратко описание на основните елементи на езика JavaScript
=========================================================

JavaScript е динамично типизиран език: променливите не носят определен тип, 
а всяка приема стойности от всякакъв тип.

Типовете на стойности са число, булев, низ, обект и неопределен.
Последният отговаря на незададена стойност, означавана с името undefined.
Името null също в известен смисъл отговаря на неопределена стойност,
но е от тип обект.

Целите и нецелите числа образуват един числов тип: 64-разредни числа с плаваща
точка. Булевите стойности са false и true.

В езика широко се използват функции и масиви. И двете не са самостоятелни
типове, а обекти, но операцията typeof (виж по-долу) различава функциите сред
останалите обекти.

Низовете могат да съдържат всякакви литери от Уникод и са неизменяеми стойности.
В явен вид се записват във вида '…' или "…".

JavaScript е обектноориентиран в прототипен стил език. За всеки обект X има
посочен наследяван обект („прототип“) P, чиито членове са несобствени членове
на X. Наследяването е транзитивно: X наследява не само собствените, а и
наследените членове на P, така че всички членове на P са и такива на X.

Всеки член на обект има име – низ или символ. Цитирането на член става с израз
от вида O[E] или O.N, където O посочва обекта, E е израз, чиято стойност след
евентуално превръщане в низ или символ дава името на члена, а N е непосредствено
такова име – съдържанието на съответния низ.

С фо̀рмата O[E] се цитира и елемент на масив или низ – тогава стойността на E
трябва да бъде целочислен израз, отговарящ на индекса. Това число се превръща
в низ.

Един начин да бъде създаден обект е да се обърнем към (коя да е) функция f
чрез операцията new. Такова повикване има вида new f(…) – прилагаме new към
f в ролята ѝ на обект и наред с това на конструктор на обекти. Прототип на
новообразувания обект става стойността на члена prototype на f по време на
създаването. В самата f променливата this сочи тъкмо новообразувания обект,
с което дава възможност за цитиране на членовете му, включително за да бъдат
те създадени.

Чрез стойността на new.target в тялото на функция може да се различи дали
дадено нейно повикване е чрез new: ако е така, стойността е препратка към
повиканата функция и има член name – името на функцията, иначе е undefined.

Два обекта могат да имат един и същи конструктор и да наследяват от различни
прототипове, както и да имат общ прототип, но различни конструктори.

Обикновено конструкторът не произвежда стойност и тогава резултатът от new
е новообразуваният както бе описано обект. Ако конструкторът произвежда (чрез
return) стойност обект, тази стойност и става резултат от new. В този случай
функцията би имала за резултат все същия обект и без да бъде повикана с new,
но прототипът, който тогава ще има обектът, е въобще казано друг.

При образуването ѝ за всяка функция, вкл. метод, автоматично се създава член
prototype, чиято стойност е обект с единствен член constructor, стойността
на който е функцията. Така обектите, породени чрез new с тази функция като
свой конструктор разполагат с препратка към нея в лицето на наследения член
constructor. По този начин, от една страна, функцията конструктор се оказва
метод на създаваните от нея обекти и в частност те могат да я използват отново
като конструктор. От друга страна, чрез достъпа до конструктора си образуваните
обекти имат достъп и до членовете му като обект.

Ако в програмата променим члена prototype на използвана като конструктор
функция, предаването към образуваните от нея обекти на препратка към
конструктора им вече няма да е по подразбиране, но ако е нужно да го има,
то може да бъде осигурено чрез явно присвояване.

„Частни“, невидими за наследяващите обекти членове могат да се обособят
например като обектът, от който се наследява, е функция, членовете на която
като обект се създават в контекста на изпълнението ѝ. Тези членове от една
страна се наследяват, а от друга – те и само те имат достъп до локалните
променливи на функцията, които следователно играят роля на частни членове.

Обектът Object е „главен“ – той съдържа някои методи с общо за обектите значение.

Съществува и т.нар. глобален обект, съдържащ няколко предопределени глобални
константи и функции. Определяните в програмата глобални функции и променливи
също са членове на глобалния обект. Всички такива, предопределени и определени
в програмата, се цитират пряко или като членове на глобалния обект. Той, на
свой ред, на глобално равнище се цитира с this.

Object, Function, Number, Array, String, Date, RegExp и др. са методи на
глобалния обект, конструктори на общ и специфични видове обекти. Обектът Math
също е член на глобалния обект и е библиотека от полезни числови константи и
функции.

Специалната променлива this сочи един или друг обект, който играе ролята на
контекст за изпълнението на функция или на отделно действие. В действията
на глобално равнище this сочи глобалния обект. Така е и в тялото на функция,
която не е метод на обект и не е повикана чрез new – дори когато повикването
става в метод или в повикана с new функция. В тялото на метод, ако той не е
повикан чрез new, this сочи обекта притежател на метода. В тялото на повикана
чрез new функция, дори ако тя е метод, this сочи образувания чрез повикването
обект (така функцията се държи като метод на този обект).

Пряко задаваните обекти, както и създаваните с new Object() имат за наследяван
обект Object.prototype.

На функциите конструктори може да се гледа като на класове и да се постигне
„класово“ наследяване на A от B – обектите с конструктор B да наследяват това,
което наследяват и тези с конструктор A, заедно с друго, изрично посочено:
    B.prototype = Object.create(A.prototype)
    B.prototype.constructor = B
    B.prototype.… = …             // други наследявани членове
Като правило, тялото на конструктора B ще съдържа повикване на конструктора A
с новосъздадения обект за контекст:
    A.call(this,…)

Непосредствено образувани масиви:
    []
    a = ['ab',5,-4,true]
    a.b = 'cuc'+'koo'
    // a.length === 4
    // a['b']+a[1] === 'cuckoo5'

Непосредствено образувани обекти:
    {}
    a = {x: 3, y: -2, 56: function() {return 7*t}, 'a-b': true}
    // a.y === -2
    // a['56'] === a[56]
    // typeof a[56] === 'function'

Имената и на членове на обект изобщо, и на елементи на масив в частност, се
привеждат към низове. Във втория случай за елементи на масива се смятат тези
негови членове, чиито имена са низове, съдържащи цели неотрицателни числа.
Членовете с други имена принадлежат на обекта, но не са елементи на масива.

Програмен къс може да съдържа три вида неща:
    • определения на функции;
    • определения на глобални променливи;
    • команди.
Всеки програмен къс може да се смята за самостоятелна програма.
Програмните късове се компилират в глобален контекст и могат да споделят
глобални променливи.

За разделяне на команди се използват знаци точка и запетая (;), но те са
незадължителни. Съществуват някои ограничения за пренасяне и съединяване
на команди по редове, ако не се използват ;.

За поредово изпълнение в браузър може да се използва „уеб конзолата“ –
Ctrl-Shift-i във Firefox и Ctrl-Shift-j или Ctrl-Shift-i в Chrome или Chromium.
Във Firefox там е възможно също въвеждане, редактиране и изпълнение и на цели
откъси.

Операции като в езика C и др.:
    едноместни ++ -- ~ !
    двуместни  + - * / % ** == != < <= >= > && ||
               & | ^ << >> , = += и т.н.
    триместни  ?:
        13%(-5) == 3
        (-13)%5 == -3
        13%5.2-2.6 < Number.MIN_VALUE
        3**1.2 === 3.7371928188465517
Други операции:
    void …       аргументът се пресмята, но резултат е стойността undefined
    typeof …     резултатът е 'number', 'boolean', 'string', 'undefined',
                   'function' или 'object'
    >>>          като >>, но попълва с 0
    === !==      строго сравняване (при == и != се подразбира привеждане)
    + +=         слепват низове
    < <= >= >    сравняват се низове като думи в речник
    ??           първият аргумент, а ако той е null или undefined – вторият
                 (подобно на ||, но не за всички „неистини“)
    ??=          присвояване на първия аргумент, ако той е null или undefined
    ?.           пред цитиране на член на обект чрез име или [] или () за метод,
                 – ако членът липсва, дава undefined за цялата верига ...?.nnn.nnn....
Операциите in, delete и instanceof са описани по-долу.

Следните изрази имат стойност true:
    typeof null === 'object'
    typeof [] === 'object'               // и за всеки друг масив
    typeof {} === 'object'               // и за всеки друг обект

Множество привеждания по тип се извършват по подразбиране (неявно). Например
където се очаква булева стойност всяка от следните стойности се тълкува като
неистина:
    false null NaN undefined 0 '',
а всички останали – като истина. Където се очаква низ, стойността се
преобразува в низ. Където се очаква число – преобразува се в число.
В операции от вида число + низ и низ + число става преобразуване към низ.

Следните изрази имат стойност true благодарение на неявни преобразования
и други особености на стойностите:
    !0
    !''
    !NaN
    !undefined
    !!3
    !!'z'
    !![]
    ('' && 52) === ''
    ('z' && 52) === 52
    ('z' && 0 && [3,5,8]) === 0
    (52 || '') === 52
    (1 < 0 || 'z') === 'z'
    (1 < 0 || 'z' || undefined) === 'z'
    NaN !== NaN
    typeof NaN === 'number'
    isNaN('z')
    false == 0
    false == '0'
    3.0 == '3'
    3.0 !== '3'
    null == undefined
    null !== undefined
    true-false === 1
    +true === 1
    3+true === 4
    true+true === 2
    [3][0] === 3
    +'3' === 3
    +[3] === 3
    [3] == 3
    [3] == '3'
    3+'' === '3'
    ''+3 === '3'
    ''+true === 'true'
    []+3 === '3'
    ''+[1,2,3] == '1,2,3'
    [1,2]+3 === '1,23'

Явно преобразуване се извършва с функциите Boolean, Number, String и Object,
а също с метода toString, наличен за всяка стойност, освен null и undefined,
и метода JSON.stringify. Последният е удобен за „виждане“ като низ на
съдържанието на масиви и други обекти.

    Boolean([])
    Boolean({})
    Number([]) === 0
    Number([0]) === 0
    Number([3]) === 3
    String([]) === ''

    Boolean() === false
    Boolean(0) === false
    Boolean(3)
    Boolean('z')

    Number() === 0
    Number(false) === 0
    Number(true) === 1
    Number(' 73.6  ') === 73.6

    String() === ''
    String(false) === 'false'
    String(true) === 'true'

    JSON.stringify(Object()) === '{}'
    JSON.stringify(Object().valueOf()) === '{}'
    JSON.stringify(Object({})) === '{}'
    JSON.stringify(Object({}).valueOf()) === '{}'
    Object({}) != Object({})
    Object(3) == 3
    Object(3) !== 3

    73 .toString() === '73'
    Number(73).toString() === '73'
    73.6.toString() === '73.6'
    73.6.toString(16) === '49.999999999998'

Числа могат да бъдат превръщани в низ и чрез форматиране:

    73.6.toFixed(4) === '73.6000'
    73.6.toFixed(0) === '74'
    73.6.toPrecision(6) === '73.6000'
    73.6.toPrecision(2) === '74'

Преобразуване от низ в число (четене на число) става с глобалните функции
parseInt и parseFloat:

    parseInt('73.6') === 73
    parseInt('73.6',8) === 59
    parseInt('f5de',16) === 62942
    parseInt('0xf5de') === 62942
    parseFloat('  73.6 см') === 73.6

Командата var създава една или повече променливи и възможно им присвоява
стойности. Когато командата е изпълнена в тялото на функция, променливите
стават локални в нея, в противен случай – глобални (достъпни за всички функции).
Име без определение чрез var се тълкува като глобална променлива.

Командата let определя променлива с блоков обхват и възможно ѝ присвоява стойност.

Командата const определя именована константа с блоков обхват.

Локална променлива може да се определя и инициализира навсякъде в тялото на
функция и повече от веднъж. Създава се винаги само една променлива, а областта
ѝ на действие е цялото тяло. Всяко инициализиране е равнозначно на присвояване.

Определение на функция:
    function име(имена-на-параметри) { … }

Определение на функция не може да бъде част от команда – блок (освен тяло на
функция), if, цикъл и т.н., но определения на функции могат да бъдат вложени
едно в друго.

Функционна стойност:
    function (имена-на-параметри) { … }
    function име(имена-на-параметри) { … }
Втората форма е същата като определение на функция, но се използва като израз,
образувайки стойност. Тогава името е локално – то обозначава функцията само в
тялото ѝ, така че тя напр. да може да повиква себе си (рекурсивно).

Когато елемент на масив е функция, той е метод на обекта-масив и при повикване
променливата this в тялото му сочи масива.

    [ function(n) { return n < 2 ? 1 : n * this[0](n-1) } ] [0] (5) === 120

Команди като в езика C:
    if (…) …
    if (…) … else …
    switch (…) {case …}
    while (…) …
    do {…} while (…)
    for (име=…; …; …) …
    continue
    break

Други команди:
    for (име of масив) …              изброяване на елементите на масив (ES6)
    for (име in масив-или-обект) …    изброяване на индексите на масив или
                                        на имената на изброимите членове
                                        (вкл. несобствените) на обект; членове
                                        могат да се изтриват при изброяването
    continue …                        към посочен цикъл
    break …                           към посочена обхващаща команда
    try–catch–finally + throw         подобно на Java

Във всяка от командите for пред името може да има var или let – съответно за
променлива, локална в тялото на функцията или за цикъла.

Членове на глобалния обект
--------------------------
NaN          нечисло
Infinity     „безкрайност“
undefined    undefined
isNaN        истина, ако аргументът е NaN (x е NaN ако и само ако x !== x)
isFinite     истина, ако аргументът е число и не е Infinity, -Infinity или NaN
parseInt     извличане на цяло число от низ   / остатъкът от низа след числото
parseFloat   извличане на число от низ        \ може да съдържа и друго
eval         изпълнява низ като програмен къс; връща аргумента, ако той не е низ;
             изпълнението е в локалния контекст, ако eval се цитира пряко под
             това име, в противен случай – в глобалния

    Infinity === Infinity
    -Infinity < Infinity
    Infinity+100 === Infinity
    Infinity-100 === Infinity
    Infinity*(-100) === -Infinity
    isNaN(Infinity-Infinity)

Операции с Object
-----------------
x in o               проверява за притежаване от o на член x (вкл. undefined)
delete o.x           унищожава член x на обект o
o instanceof C       проверява дали o наследява от C.prototype

Членове на Object
-----------------
create                  създава обект с посочен като аргумент прототип
assign(o₁,o₂)           добавя членовете на o₂ към o₁ (променя или създава нови)
prototype               прототип на създадените пряко или с new Object() обекти
getPrototypeOf          обектът прототип на даден обект
defineProperty(o,e,d)   създава или променя o[e] с описателя d от вида
                        ({value: v, writable: b}), дава o; след това o[e] === v
keys                    имената на изброимите собствени (не наследени) членове
getOwnPropertyNames     имената на всички собствени членове
freeze                  прави множеството от членове, самите членове и прототипа на
                        обект неизменяеми и дава обекта; обект с неизменяем прототип
                        не може да има собствен вариант на наследено от прототипа
                        свойство
isFrozen                проверява дали даден обект е неизменяем

Методи на Object.prototype
--------------------------
valueOf              „простата стойност“ (има смисъл само за Number и Boolean)
toString             низ (представянето на обекта като низ)
hasOwnProperty       проверява за пряко притежаване на член
isPrototypeOf        проверява дали обектът е в прототипната верига на аргумента

Членове на Function.prototype
-----------------------------
toString     низ (представянето на функцията като низ)
call(o,…)    повиква функцията като метод на обекта o с аргументи …
apply(o,a)   като call, но аргументите са от масива a
bind(o,…)    образува от функцията метод на обекта o с фиксирани стойности … на
               аргументите и без член prototype

call, apply и bind дават възможност каква да е функция да се изпълни в контекста
на обект, като this в тялото ѝ сочи този обект. Това е така дори ако функцията
е метод на друг обект.

Операцията Function(…) или (в случая същата) new Function(…) създава функция
от параметри и тяло, зададени като низове – тялото е последният параметър.
Независимо от мястото на създаването, то става в глобалния контекст, така че
образуваната функция има достъп само до наличното в него.
Следните два израза образуват една и съща функция:
Function('x','y','{return x+y}')     Function('x,y','{return x+y}')

Членове на функционни екземпляри
--------------------------------
length               броят параметри, посочен в описанието на функцията

Обекти във функционни екземпляри
--------------------------------
arguments            масивоподобен обект с аргументите на повикването
arguments.length     брой аргументи
arguments.callee     изпълняваната функция (удобно за направа на анонимна
                       рекурсивна функция и за цитиране на собствени членове)
prototype            обект за наследяване от конструираните с функцията обекти

Членове на Number
-----------------
MIN_VALUE           най-малкото представимо >0 число
MAX_VALUE           най-голямото представимо число
POSITIVE_INFINITY   Infinity
NEGATIVE_INFINITY   -Infinity
EPSILON             най-малкото число x, за което 1+x > 1 (~2.22e-16)
MAX_SAFE_INTEGER    9007199254740991; задава границите на симетричен интервал,
                    в който целите числа са гарантирано точно представими
isInteger           true за целите числа от сигурния интервал, но и за всички
                    по-големи числа

Членове на Number.prototype
---------------------------
valueOf             числото
toString            низ, представящ числото
toFixed(n)          низ със закръгляне на n (подразбира се 0) знака след точката

Членове на Math
---------------
SQRT2 SQRT1_2
PI E
LN2 LN10               натурални логаритми от 2 и от 10
LOG2E LOG10E           двоичен и десетични логаритми от e
abs
sign
min max                с произволен брой аргументи
ceil floor trunc round точните половинки се закръглят нагоре
sqrt
hypot                  с произволен брой аргументи
pow                    x**y
exp log log2 log10     експонента, натурален, двоичен и десетичен логаритъм
cos sin tan
acos asin atan atan2   ∈ [-π,π]
random                 ∈ [0,1)

Конструктор и членове на Array
------------------------------
Array(n)            създава масив с дължина n
Array(x,…)          създава масив от посочени елементи – 0, 2 или повече на брой
Array.isArray       проверява дали даден обект е масив

Членове на Array.prototype
--------------------------
toString            низ (представянето на масива като низ)
indexOf(x[,i])      търси x от i, сравнявайки чрез ===; при неуспех дава -1
lastIndexOf(x[,i])  подобно на горното, но от края назад
includes()          проверява за наличие на член
find(f)             дава първия елемент, за който f дава истина, или undefined
findIndex(f)        дава индекса на първия елемент, за който f дава истина, или -1
pop                 дава последния елемент и го премахва от масива, или undefined
push                добавя в края елементи, дава новата дължина
shift               като pop, но с първия елемент на масива
unshift             като push, но в началото на масива
slice(±i[,±j])      подмасивът за индекси [i,j)
fill(x[,±i[,±j]])   променя на x стойностите в [i,j), дава масива
map(f)              нов масив чрез поелементно действие на f
filter(f)           нов масив от елементите, за които f дава истина
forEach(f)          изпълнява f за всеки елемент, не дава стойност
reduce(f[,u])       лява редукция (fold), дава акумулирана стойност
reduceRight(f[,u])  дясна редукция (fold), дава акумулирана стойност
every(f)            true, ако f е истина за всички елементи
some(f)             true, ако f е истина за поне един елемент
concat              добавяне на масиви и други стойности
join(dlm)           образува низ, за разделител подразбира ','
reverse             обръща и дава масива, не поражда нов
splice(i[,n[,…]])   изтрива n елемента и добавя посочени, не образува нов масив,
                      дава масив от изтритите
sort                подрежда и дава масива, не поражда нов; подразбира речниково
                      сравняване чрез превеждане в низове; иначе (<|=|>)0
Функцията f в map, filter, forEach, reduce, reduceRight, every и some може да
приема допълнителни аргументи – текущия индекс и масива.

Членове на масиви
-----------------
length              присвояване изменя размера на масива

Всяка от функциите filter, map, forEach, every и some може да работи с
неплътни масиви и вижда измененията на все още непреминатите елементи,
но не нови елементи. Функциите-параметри могат да приемат и индекса,
и масива като цяло, а самата функция – обект-контекст за this.

reduce и reduceRight също могат да приемат като аргументи индекса и масива.

splice() е и вмъкване, и изтриване, и замяна на подмасив, и извличане (изваждане
от масива).

Членове на String
-----------------
fromCharCode         низ по изброени уникодове

Членове на String.prototype
---------------------------
length               дължината на низа
valueOf              низът (същото като toString)
toString             низът
charAt               литерата с посочен индекс (като [], но [] е възможно
                       по-ефективно)
charCodeAt           уникодът (code unit) с посочен индекс
codePointAt          уникодът на литерата (full char) с посочен индекс
                       (for (c of s) ...codePointAt(0)... дава правилно
                       изброяване и правилни кодове)
substring(i[,j])     поднизът за индекси [i,j)
indexOf(s[,i])       като за масиви
lastIndexOf(s[,i])   като за масиви
startsWith(s)        равнозначно на indexOf(s)===0
endsWith(s)          равнозначно на lastIndexOf(s)+s.length===length
includes(s)          проверява за наличие на подниз       
search               като indexOf, но с regex и с фиксирано начало
slice(±i[,±j])       поднизът за индекси [i,j)
toLowerCase          съответен низ от малки букви
toUpperCase          съответен низ от главни букви
trim                 низ от низа без началните и крайни шпации и подобни
split(dlm[,n])       разбива низа чрез разделител (низ или regex), дава ≤n части
concat               добавя низове
match                масив от съответствия с regex или null, различен (!) за
                       единично и глобално търсене
replace(кое,какво)   заменяне, „кое“ може да бъде и regex, вкл. с признак g

Някои идиоми за масиви и низове
-------------------------------
  • Прилагане на масивов метод f с аргументи … върху низ s:
      Array.prototype.f.call(s,…) или [].f.call(s,…)

  • Масив от елементите на низ s:
      s.split('') или [].slice.call(s,0)

  • Низ от n повторения на низ s:
      Array(n+1).join(s)

  • Копиране на масив a:
      a.concat()  или  a.slice(0)

  • Образуване на масив от псевдомасив a:
      [].slice.call(a,0)

Членове на RegExp.prototype
---------------------------
toString             низ (представянето на regex-а като низ)
/…/.exec(s)          масив от съответствия с низа s или null
/…/.test(s)          булево: дали exec намира съответствия с низа s или null
lastIndex            индекс след последното съответствие, за глобално търсене

————————————————————————————————————————————————————————————————————————————————
Б.Банчев
