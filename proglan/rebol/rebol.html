<html>
<head>
<title>REBOL – кратки сведения</title>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type">
<style type="text/css">
body {
  margin-top: 0%;
  margin-left: 15%; 
  margin-right: 15%;
  font-size: 14pt;
  text-align: left;
}
h2 {
  font-size: 18pt;
  font-weight:bold;
  border-radius:.3em;
  background-color:lightgrey;
  text-align:left;
  hyphens: none;
  margin-top:2em;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
}
h3 {
  font-size: 16pt;
  font-weight:bold;
  text-align:left;
  hyphens: none;
}
p {
  margin-top:.4em;
  margin-bottom:0em;
  text-indent:2em;
}
code,pre {
  font-family:Ubuntu Mono,Consolas,monospace;
}
code {
  font-size: 16pt;
  font-weight:bold;
  text-decoration:none;
}
pre {
  font-size: 14pt;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
  margin-top:.4em;
  margin-bottom:.2em;
}
</style>
</head>
<body>
<h2>Работа с REBOL (REBOL 2) в MS Windows</h2>

<p>Изтеглете файла <code>https://www.rebol.com/downloads/v278/rebol-view-278-3-1.exe</code> и го поставете в подходяща самостоятелна директория.</p>

<p>За работа с REBOL файлът може да се използва по един от двата начина:<br>
        – като го изпълнявате непосредствено сам по себе си;<br>
        – като веднъж го изпълните, за да създадете местна инсталация, а всяко последващо изпълнение използва тази инсталация.</p>

<p>Вторият начин е за предпочитане – при него в избраната директория се записват трайно поддиректории и файлове, които иначе се налага да се „четат“ посредством Интернет при всеки сеанс на работа с REBOL.
Нататък предполагаме именно този начин на работа.
Образуван е файл <code>rebol.exe</code>, който изпълняваме, за да работим с REBOL.</p>

<p>Прост начин да се изпълни записана във файл програма на REBOL е да се „влачи“ файла върху <code>rebol.exe</code>.
Този начин обаче е и много ограничен откъм възможности за взаимодействие с изпълняващата система на REBOL.</p>

<p>Изпълняващата система има два режима на работа: прозоречен диалог, наричан REBOL Desktop, и конзолен – REBOL Console.
Това са две различни работни състояния на системата – във всеки момент действа или едното, или другото.
При стартиране на системата тя се намира в режим Desktop.</p>

<h3>Работа в REBOL Console</h3>

<p>Основния начин за изпълняване на програми дава конзолният режим.
В него се попада, като в режим Desktop щракнете върху <b>Console</b> най-отдолу в лявата вертикала от икони.
В конзолния режим може да се пресметне кой да е израз, да се получи справка и да се изпълняват някои други команди.
По начин на работа конзолният режим на REBOL е аналогичен на конзолата, т.е. командния интерпретатор, на операционната система, но служи за взаимодействие именно с REBOL, а не с о.с.</p>

<p>За да се прочете и изпълни от конзолата файл с програма на REBOL се използва командата <code>do</code> с аргумент име на файл.
Например <code>do %/c/mydir/myprog.r</code> изпълнява файла <code>myprog.r</code>, намиращ се в директорията <code>c:\mydir</code> на диска <code>c:</code>.
Типично е такъв файл да съдържа определения на функции и други стойности.
Изпълнявайки определенията, те стават известни на интерпретатора, така че след това могат да бъдат използвани в повиквания и пресмятане на изрази.
Повиквания и пресмятания с направените във файла определения може да има и в самия него.</p>

<p>Командата <code>help</code> служи за показване на справка за функция или друг именован обект.
Например <code>help copy</code> извежда в конзолата справка за функцията <code>copy</code>.
Справки може да се поместват и в определяните от потребителя функции – тогава те също се показват.
Повикването на <code>help</code> без аргумент извежда справка за използването на самата команда.</p>

<p>За преминаване от конзолен към прозоречен режим от командния ред на конзолата се изпълнява командата <code>desktop</code>.</p>

<p>Командата <code>quit</code> завършва действието на интерпретатора на REBOL и води до напускане на системата.
(Ако например тя се изпълни в конзолен режим, тя води до излизане не само от него, а от системата като цяло.)</p>

<h3>Работа в REBOL Desktop</h3>

<p>Удобна форма за показване на справочна информация дава избирането на <code>REBOL -> Tools -> Word Browser</code> – отляво и после съответните полета в основния прозорец.
Информацията се показва в тематични групи (<code>Categories</code>) от съответните имена (<code>Words</code>).
Някои имена попадат в повече от една групи.</p>

<p>Директорията <code>Local</code>, достъпна чрез щракване в лявата вертикала от икони, предлага един начин да се съхраняват потребителски програми, така че удобно да се намират, изпълняват и изменят.</p>

<p>Избирането на кое да е от следните:<br>
<code>          REBOL -> Demos</code><br>
<code>          REBOL -> Games</code><br>
<code>          REBOL -> Tests</code><br>
<code>          Public -> Library -> Scripts</code><br>
показва различни множества от примери на графични програми.
Тези програми са показателни за изразителните възможности и лаконичността на езика.</p>

<h2>Съдържание на езика REBOL (REBOL 2) – вградени функции и друго</h2>

<p>За подробна информация по съдържанието на езика ползвайте някой от споменатите по-горе два начина, а още по-добре уебадресите <code>https://www.rebol.com/docs/core23/rebolcore.html</code> (справочник на потребителя) и <code>https://www.rebol.com/docs/dictionary.html</code> (азбучен показалец).
Следното е кратка и много непълна извадка от тези източници.<br><br></p>

<pre>
none и булеви стойности
-----------------------
none                „нестойност“

false               неистина

true                истина

and                 логическо „и“

or                  логическо „или“

not                 логическо отрицание

В контекст на условие всички различни от none и false стойности се разглеждат като „истина“.


действия с редици
-----------------
next s              следващ курсор

back s              предходен курсор

skip s n            следващ на n стъпки курсор

head s              курсор към началото

tail s              курсор след края

head? s             в началото?

tail? s             след края?

length? s           дължината

index? s            къде спрямо началото (от 1 до #s+1)?

offset? s s         дължината на частта от редицата в полуотворения интервал

first s             съответният по поредност член спрямо курсора
second s            (не действителното начало)
third s             - - -
fourth s            - - -
fifth s             - - -

last s              последният член

pick s i            член по поредния му номер спрямо курсора (не началото)

s/i                 като pick, но само за име s и константно i

insert s v          вмъква преди мястото, което сочи s; резултатът е курсор
                    след мястото на вмъкването
    /part s v s     само част от v (до къде), ако е редица
    /part s v n     само част от v (брой членове), ако е редица
    /dup n          брой пъти
    /only

append s v          добавя v към редицата s, все едно insert tail s v
    /only           ако v е редица, остава единичен член на s

alter s v           добавя v, ако отсъства, а ако не – премахва я от s;
                    връща true при добавяне

copy s              копие на член или отрязък
    /part s s       (полуотворен интервал)
    /part s n       (начало и брой)
    /deep s

remove s            премахва член(ове) от даденото място
    /part s s
    /part s n

remove-each име s b премахва всеки член на s, за който пресмятането на блока b дава вярно
                    (променя самата редица, не образува копие)

reverse s           обръщане на частта от редицата от s нататък

clear s             изтрива до края

poke s i v          променя стойността по зададен пореден номер в редицата

change s v          променя отделен член или отрязък
    /part s v s     само част от v (до къде), ако е редица
    /part s v n     само част от v (брой членове), ако е редица
    /dup n
    /only

replace s v₁ v₂     заменя един или всички
    /all

reduce блок         пресмятане на изразите в блок, дава блок от стойности

compose блок        като reduce, но пресмятане само на изразите в скоби ( и )
    /deep           пресмятане и на вложени в скоби изрази

join v s            образува редица с типа на v от членовете на v и s;
                    ако v не е редица, преобразува се в низ;
                    ако s е блок, членовете му се пресмятат

rejoin s            като join, но за първи аргумент се взема първият член на s,
                    а за втори – остатъкът на s, и двете след пресмятане в s

union s₁ s₂         обединение

intersect s₁ s₂     сечение

exclude s₁ s₂       разликата s₁\s₂

difference s₁ s₂    симетрична разлика

unique s            множеството от членове, всеки по веднъж

find s v            търсене на стойност или тип; връща курсор или none
find s t

extract s n         редица от извлечени членове през n броя (n-1 пропуснати)
    /index i        задава начало

sort s              подреждане на числа, низове, времена, дати, пари и др.
    /skip i         сравняват се подредици от по i броя (вместо от по 1)
    /reverse        в обратен ред
    /compare f      с изрично зададен предикат за сравняване


специфично за низове
--------------------
{...}               низ с посочено съдържание

"..."               низ с посочено съдържание

#"…"                литера с посочено съдържание

^/                  „нов ред“ в низ

^-                  „табулация“ в низ

^"                  " в низ

^}                  } в низ

^(xx)               ASCII xx (16-чно) в низ

uppercase s         превръщане в низ от главни букви (същия низ)
    /part дължина

lowercase s         превръщане в низ от малки букви (същия низ)
    /part дължина

trim s              изтрива шпации и др. под. (в същия низ); има множество уточнители

form v              образува „удобен за четене и печатане“ (все едно от prin) низ
                    от каква да е стойност

mold v              образува четим от REBOL низ за стойността

reform              прилага reduce и form

remold              прилага reduce и mold

as-binary s         образува 16-ен низ (от тип binary!): #{...hex-string...}

as-string s         образува низ от тип string! от какъв да е низ

dehex s             заменя тройки %xx със съответната литера

compress s          образува 16-ен низ чрез уплътняване на даден низ

decompress s-bin    образува низ от тип string! от уплътнен

read-cgi            низ от уебсървър

decode-cgi s-cgi    образува блок от двойки – имена и прочетени стойности


управление
----------
if израз блок       условно изпълнение на блока

either израз блок блок
                    условен избор между две действия

any блок            пресмятане на изразите в блока до намиране на истинен;
                    ако има такава стойност, тя е резултатът, иначе – none

all блок            пресмятане на изразите в блока до намиране на неистинен;
                    ако има такава стойност, резултатът е none, иначе –
                    последната пресметната
                   
select редица ключ  ако се намери стойността ключ в редицата, дава се следващата 
                    я стойност, v; ако не се намери или няма v – none;
                    често след select се изпълнява  if v [do v]

switch ключ блок
switch/default ключ блок блок
                    подобно на select, но избраното се изпълнява и се дава
                    резултатът от това изпълнение; вторият вариант задава и
                    действие при ненамиране

case блок           блокът е редица от двойки булев израз – блок; изпълнява се
    /all            първият блок, чието условие е истинно; при /all се изпълняват
                    всички блокове с истинни условия

try блок            блокът или се пресмята успешно и се дава произведената от
                    него стойност, или завършва с грешка (което се проверява с
                    предиката error?)

throw израз         излъчва от блока признак за грешка, заедно със стойността
                    на израза

catch блок          прехваща и дава излъченото от throw

attempt блок        съкратен израз за error? try <block>

until блок          пресмята блока, докато се получи истина и дава тази стойност

while блок блок     пресмята втория блок всеки път щом първия даде истина, след
                    което завършва

loop цяло блок      премята блока посочения брой пъти

repeat име цяло блок
                    подобно на loop, но с достъп до брояча под посоченото име

for име от до стъпка блок
                    обхождане на аритметична прогресия с достъп до брояча

foreach име редица блок
                    пресмятане на блока, като името обхожда членовете на редицата;
                    вместо едно може да има блок от имена, за обхождане по групи

forall редица блок  блокът се изпълнява за всяка стойност на курсора до края ѝ

forskip редица стъпка блок
                    подобно на forall, но с изрично зададена стъпка на курсора

forever блок        безкраен цикъл

break
break/return израз  прекъсване на цикъл; във втората форма с даване на резултат

return израз        завършване на функция с даване на резултат

exit                завършване на функция без даване на резултат

halt                връщане към конзолата на REBOL

quit                излизане от интерпретатора


функции
-------
function параметри локални тяло
                    образуване на функционна стойност от блок от имена-параметри
                    (и уточнители), блок от локални имена и блок-тяло

func параметри тяло опростен вариант на function, без задаване на локални имена,
                    определен така:
                    func: make function! [params body] [make function! params body]

does блок           опростен вариант на func, без задаване на параметри


разни
-----
'име                името като „дума“

име:                цитиране на променлива при присвояване

:име                цитиране на функционната стойност на променлива

set 'име стойност   присвоява стойност на променливата с посоченото име
set блок блок       множествено присвояване

get 'име            стойността на променливата с посоченото име

prin израз          печатане в конзолата на стойността на израза

print израз         като prin, но после минава на нов ред

probe стойност      печатане като през mold и даване на стойността
                    (удобно за проследяване на стойности)

word!               типовете на стойности – самите те от тип datatype!
char!
string!
block!
integer!
decimal!
...

word? израз         проверяване дали типът на дадена стойност е посоченият с името
char? израз
string? иараз
block? израз
integer? израз
decimal? израз
...

type? израз         типът на стойността на израза

do израз            изпълняване на интерпретатора върху аргумента
do низ
do име-на-файл

load низ            прочитане на съдържанието на аргумента, образуване на стойност
load име-на-файл
load уебадрес

make тип аргументи  образуване на стойност от посочения тип с посочените атрибути


смеси („обектни“ стойности)
---------------------------
make object! [име: стойност ...]
                    образуване на смес („обект“) с посочените имена на членове и стойности

make обект [име: стойност ...]
                    образува нов обект от друг, добавяйки имена на членове и стойности
                    или променяйки стойности

обект/име           цитиране на член на обект

self                име на член със стойност препратка към дадения обект

in обект 'име       името на член в контекста на обекта (или none); така може да се цитира
                    член с непряко (като стойност) посочване на името – удобно за get или set

first обект         блок от имената на членовете на обекта, вкл. self

second обект        блок от стойностите на членовете на обекта, вкл. на self
</pre>
</body>
</html>
