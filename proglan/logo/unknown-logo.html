<html>
<head>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<title>Старият (не)познат Logo: примери, идеи, пропускани възможности</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<style type="text/css">
/* <uniquifier>: Use a unique and descriptive class name
   <weight>: Use a value from 100 to 900 */
.noto-serif-personalweb {
  font-family: "Noto Serif", serif;
  font-optical-sizing: auto;
  font-weight: 300;
  font-style: normal;
  font-variation-settings: "wdth" 100;
}
body {
  margin-top: 0%;
  margin-left: 15%; 
  margin-right: 15%;
  font-family:Noto Serif,serif;
  font-size: 14pt;
  hyphens: auto;
  text-align: left;
}
hr {
  border:solid 5px;
  border-radius:5px;
  color:darkgrey;
  height:0px;
  width:95%;
  text-align:center;
  margin-top:1.5em;
  margin-bottom:1.5em;
}
hr.small {
  border: solid 3px;
  border-radius: 3px;
  color: darkgrey;
  height: 0px;
  width: 40%;
  text-align: center;
  margin-top: 2em;
  margin-bottom: 1em;
}
h1 {
  font-size: 24pt;
  font-weight:bold;
  text-align:center;
  hyphens: none;
  margin-top:3em;
  margin-bottom:1em;
}
h2 {
  font-size: 18pt;
  font-weight:bold;
  border-radius:.3em;
  background-color:wheat;
  text-align:left;
  hyphens: none;
  margin-top:2em;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
}
h3 {
  font-size: 16pt;
  font-weight:bold;
  text-align:left;
  hyphens: none;
}
.subtitle {
  font-size: 16pt;
  font-weight:bold;
  text-align:center;
  hyphens: none;
  margin-top:1em;
  margin-bottom:1em;
}
p {
  margin-top:.4em;
  margin-bottom:0em;
  text-indent:2em;
}
ul {
  margin-top:0em;
  margin-bottom:0em;
}
li {
  margin-top:.3em;
  margin-bottom:.3em;
  margin-left:2em;
}
td {
  font-size: 14pt;
  text-align: left;
}
code,pre {
  font-family:Ubuntu Mono,Consolas,monospace;
  font-size: 16pt;
  color:brown;
}
code {
  font-weight:bold;
  text-decoration:none;
}
pre {
  background-color:#c0e0e0;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
  border-style:solid;
  border-width:2px;
  margin-top:.4em;
  margin-bottom:.2em;
}
a {
  color:blue;
  font-weight:bold;
  text-decoration:none;
}
a:hover {
  color:white;
  background-color:blue;
}
</style>
</head>

<body lang="bg">

\(
\def\f{\kern.1ex}
\def\ff{\kern.2ex}
\def\fff{\kern.3ex}
\def\F{\kern.4ex}
\def\b{\kern-.1ex}
\def\bb{\kern-.2ex}
\def\bbb{\kern-.3ex}
\def\B{\kern-.4ex}
\)

<h1>Старият (не)познат Logo: примери, идеи, пропускани възможности</h1>

<div class="subtitle">Бойко Банчев,<br>Институт по математика и информатика – БАН<br><code>boykobb@gmail.com</code><br><br>28.10.2024</div>

<hr>

<h2>За начало</h2>

<h3>Как възникнаха тези бележки?</h3>
<ul>
<li>Представа за същността на програмирането и на обучението по него.</li>
<li>Впечатления от начина на използване на Logo в миналото и досега.</li>
<li>Опит и размисли върху прагматиката на Logo (и няколко десетки други езика).</li>
<li>Конкретна задача от наскоро: да представя пред учители примери за използване на Logo.</li>
</ul>

<h3>За Logo</h3>

<h4>Основни черти</h4>

<ul>
<li>Създаден като език за обучение по програмиране, включително на деца. Заимства от езика Lisp.</li>
<li>Сред множеството варианти най-пълноценен като език е този на UCBLogo (Брайън Харви).</li>
<li>Всичко два вида стойности: „думи“ и редици (от думи и от други редици).</li>
<li>Думите играят роля на: <em>символни атоми</em>; <em>текстови низове</em>; <em>имена на променливи и процедури</em>.<br>
    Като низове, те допускат и действия с редици.<br>
    Елементите на дума също са думи (от по една „буква“).<br>
    За думи се смятат и числата. Например <code>-2.72</code> е число, но и дума с дължина 5.</li>
<li>Действия с редици: добавяне и отнемане в краищата, слепване, почленно цитиране и промяна;<br>
            редиците като <em>цялостни обекти</em> (свойствено на <em>функционалното програмиране</em>) –<br>
            търсене и пресяване по условие, хомогенно преобразуване, натрупващо обхождане.<br>
    Редиците служат за моделиране и на други структури от данни.<br>
<li>Процедурите не могат да се влагат една в друга, но могат да се образуват от самата програма.<br>
    Възможен е променлив брой аргументи.</li>
<li>„Костенурка“: положение, посока и писалка. Положение, цвят и дебелина на писалката.<br>
    Относително и абсолютно преместване.<br>
    Фиксирана координатна система с център около този на екрана.</li>
</ul>

<p>Широко разпространено е заблуждението, че Logo е език изключително за „рисуване с костенурка“, при това само за деца, и няма какво да предложи извън графиката.
Години наред езикът бива популяризиран почти единствено чрез безкрайно повтарящо се възпроизвеждане на „венчелистчета“, „къщички“ и „човечета“ – занятие, от което не се научава много за <b>програмирането и информатиката</b>.</p>

<p><b>Забележителен по качество и обем пример в другата посока – показване на Logo като език за обучение по информатика – е работата на Б. Харви.</b></p>

<p>Колкото до графиката – за програмно създаване и възпроизвеждане на чертежи и рисунки днес има много на брой разнообразни и висококачествени средства извън Logo.</p>

<p>Чрез примерите в този текст се стремя да покажа по-разнообразно и по-съдържателно от обичайното използване на езика, наред с важни конструкции в програмирането и информатиката.</p>

<p>Примерите се изпълняват с UCBLogo.
Могат да се пригодят и за други реализации на езика.</p>

<h2>Три примера на рекурсия</h2>

<p>Процедура, която установява дали аргументът ѝ е палиндром – редица или низ, които съвпадат с обратната им редица или низ.</p>

<p>Ако редицата е празна или има само един член, тя е палиндром.<br>
Всяка друга редица е палиндром, когато и само когато нейните първи и последен членове съвпадат и редицата между тях е палиндром:</p>

<pre>
to palindrome :xs
  if (count :xs) < 2 [output "true]
  output and (first :xs) = (last :xs) palindrome butfirst butlast :xs
end
</pre>

<hr class="small">

<p>Разглеждаме полином \(\,f(x)=c_0x^n+c_1x^{n-1}+\cdots+c_{n-1}x+c_n.\,\)
Той е еднозначно представен чрез редицата \(c_0,c_1,\dots,c_n\) от коефициентите си, а записването му във вида
\[f(x)=(((c_0x+c_1)\,x+c_2)\,x+\cdots{}c_{n-1})\,x+c_n\]
води и до <b>по-просто</b> (еднообразни действия, няма степенуване), и до <b>по-икономично</b> (малък брой действия) пресмятане на полинома.<p>

<p>Вторият запис показва и рекурентна завсисимост: \(\,f(x)=g(x)\,x+c_n,\,\) където \(g(x)=\,c_0x^{n-1}+c_1x^{n-2}+\cdots+c_{n-1}\,\) е „по-къса версия“ на \(f(x)\) (зададен чрез по-къса редица от коефициенти).
Това води до следната рекурсивна процедура за пресмятане на полином с редица от коефициенти <code>cs</code> за коя да е стойност <code>x</code>:</p>

<pre>
to polynomial :cs :x
  localmake "c last :cs
  localmake "cs' butlast :cs
  if empty? :cs' [output :c]
  output (polynomial :cs' :x) * :x + :c
end
</pre>

<hr class="small">

<p>По-сложна, разклонена рекурсивност: процедурата <code>flatten</code> образува редица от думите в дадена редица – „плосък“ вариант на тази редица, като думите се срещат в същия ред.
Например</p>

<p align="center"><code>flatten [[a [b]] [[[c d] e] f] g [h [[i j]]]]</code>  \(\quad\longrightarrow\quad\)  <code>a b c d e f g h i j</code>.</p>

<p>Плоска редица образуваме, като направим това за първия ѝ член и за остатъка и съединим получените две редици:</p>

<pre>
to flatten :xs
  if or empty? :xs word? :xs [output :xs]
  output sentence flatten first :xs flatten butfirst :xs
end
</pre>

<h2>Обобщено удвояване: процедура с аргумент процедура</h2>

<p>Удвояване е прилагане на събиране към два равни аргумента – частен случай на събиране (двуаргументна операция).</p>

<p>Обобщение на това е да приложим <b>коя да е двуместна операция, не непременно числова</b>, към <b>подходящ аргумент</b>.</p>

<p>За целта определяме процедура <code>double</code>, която по кои да е зададени процедура \(f(a,b)\) и стойност \(x\) намира \(f(x,x)\).</p>

<p>Това е прост пример на действие, което необходимо има за аргумент друго действие – нещо <span style="color:blue;font-weight:bold">нетипично и дори непознато за повечето дялове на математиката, но повсеместно полезно и използвано в програмирането</span>.</p>

<pre>
to double :f :x
  output (invoke :f :x :x)
end
</pre>

<p>Примери на използване на <code>double</code>:</p>

<table><tbody>
<tr><td><code>      </code><b>Повикване</b>        </td><td><code>    </code><b>Резултат</b>    </td><td></td></tr>
<tr><td>                                           </td><td>                                    </td><td></td></tr>
<tr><td><code>      double "sum 7</code>           </td><td><code>    14    </code>             </td><td>удвояване на число (събиране на число със себе си)</td></tr>
<tr><td><code>      double "product 7</code>       </td><td><code>    49    </code>             </td><td>повдигане на квадрат (умножаване на число със себе си)</td></tr>
<tr><td><code>      double "list 4.17</code>       </td><td><code>    4.17 4.17    </code>      </td><td>редица от два равни члена – числа</td></tr>
<tr><td><code>      double "list [3 5 8]</code>    </td><td><code>    [3 5 8] [3 5 8]    </code></td><td>редица от два равни члена – редици</td></tr>
<tr><td><code>      double "sentence [3 5 8]</code></td><td><code>    3 5 8 3 5 8    </code>    </td><td>удвояване на редица</td></tr>
<tr><td><code>      double "word "ABC</code>       </td><td><code>    ABCABC    </code>         </td><td>удвояване на низ</td></tr>
<tr><td><code>      double "recip.sum 7</code>     </td><td><code>    3.5    </code>            </td><td><em>разполовяване</em> на число</td></tr>
</tbody></table>

<!--
<div style="background:gainsboro">
<p>Удобно би било да разглеждаме  <code>double "sum</code>,   <code>double "product</code>,   <code>double "list</code>  и пр. като <em>частични прилагания</em> на <code>double</code> – без втория аргумент.
Частичното прилагане има за резултат функция – специализация на <code>double</code>.
Точно така би изглеждало то в някой от съвременните функционални езици, но в Logo тази конструкция отсъства и се имитира тромаво.</p>
</div>
-->

<p>В последния пример разполовяването на число става, като за аргумент на <code>double</code> дадем процедурата <code>recip.sum</code>, намираща реципрочния сбор \(\,a{\,\uplus\,}b=(a^{{-}1}{+\f}b^{{-}1})^{{-}1}\,\) на числа \(a\) и \(b\):</p>

<pre>
to recip.sum :a :b
  output :a * :b / (:a + :b)
end
</pre>

<p>Във всички примери по-горе процедурата-аргумент е посочена по име.
Това не непременно означава, че тя съществува по начало в програмата.
Процедура, както и името ѝ, могат да бъдат образувани <span style="color:blue;font-weight:bold">в хода на действието на програмата</span>, подобно на всяка друга стойност!</p>

<p><span style="color:blue;font-weight:bold">Разбирането за действията като вид стойности сами по себе си и като такива възможно пораждани от самата програма, а не априорна и неотменна нейна част, е също изключително важна концепция в програмирането и нещо, което не познаваме от математиката.</span></p>

<p>Схващането за действията като стойности естествено води и до представата, че такива стойности – като всички останали – <span style="color:blue;font-weight:bold">не непременно са именувани</span>.
В последния пример горе вместо името <code>"recip.sum</code> аргументът на <code>double</code> равнозначно би могъл да бъде безименната процедура  <code>[[a b] :a * :b / (:a + :b)]</code>.<p>

<div style="background:gainsboro">
<p>В случая обаче е по-добре да имаме процедура с име, защото действието \(\uplus\) е твърде важно и така би могло да се използва и извън дадения пример.</p>

<p>Странната на пръв поглед операция \(\uplus\) описва голямо множество ситуации от действителността, например в планиметрията – различни зависимости между дължини, а в електротехниката – електрическото съпротивление на успоредно свързани резистори, индуктивността на успоредно свързани бобини, капацитета на <em>последователно</em> свързани кондензатори.</p>

<p>Налице е също проста и пряка връзка между двете събирания – обичайно и реципрочно, и „златното“ отношение \(\varphi\) на числа:</p>

\[\forall\,a,b,c>0:\qquad{}
\begin{array}{rcl|}
a\!\!\!&=&\!\!\!b{\ff+\f}c\;  \\
a{\,\uplus\,}b\!\!\!&=&\!\!\!c
\end{array}
\quad\Longleftrightarrow\quad{} a{\ff:\ff}b=b{\ff:\ff}c=\varphi.\]
</div>

<h2>Действия с редици и низове</h2>

<p>Низовете и изобщо редиците са основната и най-важна структура в информатиката и програмирането.
Logo, особено UCBLogo, има процедури за някои действия с редици и низове, но липсват други, твърде съществени – например за извличане, обръщане и разместване на участъци в редици.</p>

<p>Процедурата <code>take</code> извлича подредица от първите (при \(n\ge0\)) или последните (при \(n<0\)) \(|n|\) на брой члена от дадена редица, а <code>drop</code> – подредицата от онези членове, които <code>take</code> не взема.
Процедурите са определени рекурсивно.</p>

<pre>
to take :n :xs
  if :n = 0 [output ifelse word? :xs ["] [[]]]
  if :n < 0 [output drop :n + count :xs :xs]
  output fput first :xs take :n - 1 butfirst :xs
end

to drop :n :xs
  if :n = 0 [output :xs]
  if :n < 0 [output take :n + count :xs :xs]
  output drop :n - 1 butfirst :xs
end
</pre>

<p>Важно наблюдение: <code>take</code> и <code>drop</code> заедно позволяват да извлечем кой да е участък от редица.</p>

<p>Чрез това, заедно с <code>reverse</code> – за получаване на обърната редица от дадена, те позволяват да реализираме своеобразна <em>алгебра на редиците</em>.
В нея има множество съдържателни и наред с това практически полезни и програмно реализуеми твърдения.</p>

<p>Да бележим обръщането с \(\neg.\,\)
Ето някои от споменатите твърдения.</p>

<ul>
<li>Възможно е всяко разместване на кои да е два или повече участъка в редица.</li>
<li>Всяко такова разместване може да се извърши чрез последователни размени на двойки участъци, във всяка от които единият участък е начален в редицата, а другият се намира непосредствено след него.</li>
<li>Възможно е обръщане на коя да е част от редица.</li>
<li>За всяка редица \(A\) е вярно \(\neg(\neg{}A)\equiv{}A\).</li>
<li>За всяка редица, както и да е разделена на две части \(A\) и \(B\), е вярно \(\,\neg(AB)\equiv(\neg{}B)(\neg{}A)\) – „антиразпределителен закон“ за \(\neg\).</li>
<li>От горното следва \(B\bb{}A\equiv\neg((\neg{}A)(\neg{}B)),\,\) а оттук и \(\,C\bb{}B\bb{}A\equiv\neg((\neg{}A)(\neg{}B)(\neg{}C))\) – размяна на два, съседни или не, участъка в редица само с обръщания.</li>
<li>Многократно приложено, горното осигурява извършване на кое да е разместване на кои да е участъци в редица само с обръщания.</li>
</ul>

<p>Полезни занимания са както търсенето, формулирането и доказването на подобни факти, така и тяхното онагледяване чрез програми.</p>

<p>Алгебрата на редиците има интересно продължение в <em>алгебрата на правоъгълниците</em> (или правоъгълните таблици), но нея тук не разглеждам.</p>

<hr class="small">

<p>Други ценни действия с редици имат отношение към тяхното <em>съдържание</em> (а не, както дотук, само форма).</p>

<p>Така например процедурата <code>set.of</code> образува редица от членовете на дадена редица, взети само по веднъж.
Редът, в който се срещат елементите на редицата-резултат, е редът на първите срещания на тези стойности в дадената редица.
Например <code>set.of "abracadabra</code> образува низа <code>"abrcd</code>.</p>

<pre>
to set.of :xs
  if empty? :xs [output :xs]
  localmake "x first :xs
  output fput :x set.of remove :x butfirst :xs
end
</pre>

<p>UCBLogo разполага с подобна процедура <code>remdup</code>, при която обаче резултатът е образуван, кой знае защо, от последните срещания на стойностите в редицата.
Формално казано, <code>remdup</code> е равнозначна на композицията  <code>reverse set.of reverse</code>,  а <code>set.of</code> – на  <code>reverse remdup reverse</code>: още една зависимост от алгебрата на редиците.</p>

<p>Последните две процедури обхождат редица от началото към края ѝ (<code>accum.fd</code>) или в обратна посока (<code>accum.bk</code>), като последователно прилагат действие с два аргумента.
Като означим действието с \(\diamond\), двата вида пресмятане отговарят на следните схеми, където подчертаванията играят ролята на скоби – показват реда на прилаганията и съответните аргументи на \(\diamond\) в тях.</p>

\[\underline{\underline{\rule[-2ex]{0pt}{0ex}\underline{\underline{x_1 \diamond x_2} \diamond x_3} \diamond \dots} \diamond x_n}
\qquad\mbox{и}\qquad
\underline{x_1 \diamond \underline{\rule[-2ex]{0pt}{0ex}{\dots} \diamond \underline{x_{n-2} \diamond \underline{x_{n-\b1} \diamond x_n}}}}\]

<p>Схемите са приложими, ако редицата има поне два члена.
Ако е само един, той самият е резултат от двете процедури.</p>

<p>Важно е да обърнем внимание, че членовете на редицата могат да са всякакви – числа, низове или редици от общ или специален вид.
Всякакво може да е и действието \(\diamond\), стига да е приложимо към членовете на редицата.</p>

<p>В определенията на <code>accum.fd</code> и <code>accum.bk</code> действието \(\diamond\) се задава чрез параметъра-процедура <code>f</code>.
Самите определения отново са рекурсивни:</p>

<pre>
to accum.fd :f :xs [:r]
  if not empty? :r [output accum.fd :f fput first :r :xs]
  localmake "x first :xs
  localmake "xs' butfirst :xs
  if empty? :xs' [output :x]
  output accum.fd :f fput (invoke :f :x first :xs') butfirst :xs'
end
;----------------------
to accum.bk :f :xs [:r]
  if not empty? :r [output accum.bk :f lput first :r :xs]
  localmake "x first :xs
  localmake "xs' butfirst :xs
  if empty? :xs' [output :x]
  output (invoke :f :x accum.bk :f :xs')
end
</pre>

<p>Много и разнообразни действия могат да се изразят чрез <code>accum.fd</code> и <code>accum.bk</code> – това е добре познато от теорията и практиката на функционалното програмиране.
Например обръщане на редица (като при вградената процедура <code>reverse</code>) става с  <code>accum.bk "lput ...</code>.</p>

<p>В Logo няма налични някои често потребни процедури – за намиране на абсолютна стойност, на по-малко, по-голямо от две числа и др.
Ако за последното използваме безименна процедура, то например  <code>accum.fd [[a b] ifelse :a &gt;= b [:a] [:b]] ...</code>  намира най-голямото число от дадена редица.</p>
<!--
to max :a :b
  output ifelse :a >= b [:a] [:b]
end
-->

<p>Повикване от вида  <code>accum.bk "difference </code>\(a_1,a_2,\dots,a_n\,\) пресмята \(\,a_1{\f-\ff}a_2{\f+\ff}a_3{\f-\f}\cdots:\,\) сбор с редуване на знаците \(+\) и \(-\).</p>

<p>Процедурата за пресмятане на полином от по-горе може да бъде определена и така – реализирайки същата аритметична схема, но без рекурсия (или цикъл):</p>

<pre>
to polynomial :cs :x
  output accum.fd `[[u v] :u * ,:x + :v] :cs
end
</pre>

<p>Нужното повтаряне на действия се осигурява „скрито“ от <code>accum.fd</code> и за <code>polynomial</code> сега е достатъчно само да я повика с подходящия аргумент.
Аргументът тук е зададен като образувана на място за целта безименна процедура.
Процедурата има параметри <code>u</code> и <code>v</code> и пресмята израза \(\,u{\ff}x{\f+\f}v\,\) (схемата на Хорнър), като при образуване на процедурата стойността на <code>x</code> се вгражда в израза, замествайки името <code>x</code>.</p>

<p>Друг подобен на горния пример е пресмятането на верижна дроб</p>
\[a_1+\frac1{a_2+\displaystyle\frac1{a_3+\displaystyle\frac1{\ddots+\displaystyle\frac1{a_n}}}}\cdot\]

<p>Като приемем, че дробта се представя чрез редицата \(\,a_1,a_2,\dots,a_n,\,\) определяме процедурата
<pre>
to cfract :аs
  output accum.bk [[u v] :u + 1 / :v] :as
end
</pre>
с параметър такава редица.
Тази процедура пресмята тъкмо горния израз, а някои примери за използването ѝ са:<br>
<code>    cfract [1 1 1 1 1 1 1]            </code>  – добро приближение на „златното“ число  \(\displaystyle\varphi=\frac{1{+\f}\sqrt5}2\),<br>
<code>    cfract [1 2 2 2 2 2 2]            </code>  – още по-добро приближение на \(\sqrt2\)  и<br>
<code>    1 + 2 * cfract [0 1 6 10 14 18 22]</code>  – изключително добро приближение (\({\sim}10^{-13}\)) на числото \(e\).</p>

<div style="background:lavender">
<p>Наблюдението, че решаваме задачите <b>без явна форма на повторност – рекурсия или цикъл</b> – е много важно, тъй като се отнася и за много други случаи.
Процедури като <code>accum.fd</code> и <code>accum.bk</code>, както и <code>map</code>, <code>filter</code> и др. вградени в UCBLogo (но лесно се написват, където ги няма) дават възможност:</p>
<ul>
<li>да <b>третираме редиците като цялостни стойности</b>, а не почленно, а покрай това – и</li>
<li>да <b>заменим рекурентното изразяване с повикване на подходяща процедура</b>.</li>
</ul>
<p>Такива процедури реализират прости абстракции, извънредно полезни, защото обслужват много често възникващи случаи в програмирането: „пресметни … за всяко“, „избери всички, които …“, „натрупай, прилагайки …“ и др.
Техният принос за яснотата на мислене и изразяване е огромен.</p>

<p>Рекурсията е цѐнен инструмент на програмирането, но е важно да разбираме и кога и как вместо нея да използваме споменатите форми на боравене с редиците като цялостни стойности.
Още повече че, ако самият език ги предоставя, това допълнително повишава простотата и разбираемостта на програмите.</p>
</div>

<!--
<p><code>accum.fd</code> и <code>accum.bk</code> могат да се повикват и с трети аргумент.
Тогава извършваното от тях пресмятане става по схемите</p>

\[\underline{\underline{\rule[-2ex]{0pt}{0ex}\underline{\underline{\underline{u} \diamond x_1} \diamond x_2} \diamond \dots} \diamond x_n}
\qquad\mbox{и}\qquad
\underline{x_1 \diamond \underline{\rule[-2ex]{0pt}{0ex}{\dots} \diamond \underline{x_{n-\b1} \diamond \underline{x_n \diamond \underline{u}}}}}\]

<p>където \(u\) е третият аргумент – той фактически се добавя към редицата в началото или в края ѝ, откъдето започва пресмятането. 
В този случай аргументът редица или низ \(\,x_1,x_2,\dots,x_n\,\) може да е и празен, което е често срещана ситуация, и тогава резултатът на <code>accum.fd</code> или <code>accum.bk</code> е именно \(u\).</p>

<p>За намиране на дължина на редица или низ (в Logo за същото има вградена процедура <code>count</code>) можем да използваме следната процедура.
В тялото ѝ третият аргумент <code>0</code> в повикването на <code>accum.fd</code> е нужен като дължина на празна редица и заедно с това – като начална стойност за броенето на членовете на непразна редица.</p>

<pre>
to length :xs
  output (accum.fd [[n x] :n + 1] :xs 0)
end
</pre>

<p>При обхождането на редицата <code>length</code> пренебрегва последователно посещаваните нейни членове – безименната процедура <code>[[n x] :n + 1]</code> всъщност само отброява колко пъти е повикана и дава този резултат.
Повикването на <code>length</code> с <code>[2 3 5 8]</code> и <code>"abcde</code> дава съответно 4 и 5.</p>
-->

<h2>Представяне и обхождане на дървета</h2>

<p>Понятието <b>дърво</b> и неговите разновидности са особено важни и широко използвани в информатиката.
Най-общо, дървото изразява съвкупност от йерархични отношения между какви да е обекти, като един от тези обекти е върхов в йерархията – наричаме го корен на дървото.
Сред основните действия с дървета са обхожданията, а те биват няколко вида.</p>

<p>Тук разглеждаме представяне чрез Logo на дървета и на процедури за обхождания на дървета.
При това съществено се използва вече разгледаното и непосредствено представено в езика понятие редица.</p>

<p>Като особено важна употреба на понятието дърво разглеждаме как аритметични и други изрази се представят чрез дървета, а такива дървета и обхожданията им водят до удобни начини за пресмятане на изрази.
По-общо, чрез дърво може да се представи всяка синтактична конструкция, понеже такива конструкции се отличават именно с йерархичен строеж.</p>

<hr class="small">

<p>Определяме понятието <em>дърво</em> така: дървото или е празно (не съдържа възли), или е непразно и тогава има корен (главен възел) и (възможно празно) множество от непразни дървета, наследници на корена.
Наследниците на корена на дърво наричаме също поддървета на това дърво.
Рекурентното определение естествено води до рекурсивни процедури за работа с дървета.</p>

<p>Понякога е удобно множество от непразни дървета да наричаме <em>гора</em>.
Тогава дървото е или празно, или се състои от корен и гора (от наследници на корена).
Така понятията дърво и гора взаимно се определят.
Алгоритмите за някои действия с дървета също удобно се изразяват, като се възползваме от тази взаимна обусловеност на двете понятия.</p>

<p>Крайно дърво е дърво с краен брой възли.
Тук разглеждаме само такива дървета.</p>

<p>Под <em>обхождане на дърво</em> в повечето случаи разбираме образуване на редица от (стойностите на) всички или на избрана част от възлите на дървото.
Различните видове обхождания се различават по това, в какъв именно ред се вземат възлите.</p>

<p>Обхождането на слоевете на поддърво образува редица не от възли, а от слоевете на дървото.
Тъй като всеки слой е редица от възли, в този случай получаваме редица от редици от възли, а не редица от възли.
Редицата от пътища до листата също е редица от редици.</p>

<p>В процедурите по-долу представяме дърветата чрез редици: празното дърво се представя чрез празна редица, а непразното – чрез редица, на която първият член задава стойност на корена на дървото, а останалите членове, ако такива има, представят дърветата наследници на корена (и следователно са непразни редици).</p>

<p><b>Префиксно обхождане</b> – първо корена, после възлите на наследниците, като същото се прилага за всеки наследник:</p>

<pre>
to preorder :tree
  output ifelse (count :tree) <= 1 ~
           [:tree] ~
           [fput first :tree map.se "preorder butfirst :tree]
end
</pre>

<p><b>Суфиксно обхождане</b> – първо възлите на наследниците, после корена, като същото се прилага за всеки наследник:</p>

<pre>
to postorder :tree
  output ifelse (count :tree) <= 1 ~
           [:tree] ~
           [lput first :tree map.se "postorder butfirst :tree]
end
</pre>

<p>Коренът на дървото, и всеки корен на поддърво, се посещава след възлите на поредния наследник и преди тези на следващия наследник на същия корен (обобщение на т.нар. <b>инфиксно обхождане</b> на двоично дърво, където всеки корен бива посетен само веднъж – след възлите на лявото поддърво и преди тези на дясното).
Ако даден възел има само едно дърво-наследник, посещаваме го веднъж, преди възлите на наследника.
Ако възел няма наследници, той също се посещава само веднъж:</p>

<pre>
to inorder :tree
  output cond [[[(count :tree) <= 1] :tree]
               [[(count :tree) = 2] fput first :tree inorder last :tree]
               [else intersperse first :tree map "inorder butfirst :tree]]
end

to intersperse :x :as
  output accum.bk `[[u v] sentence :u fput ,[quoted :x] :v] :as
end
</pre>

<p><b>Обхождане само на листата</b> – възлите в дървото, които нямат наследници:</p>

<pre>
to leaves :tree
  output ifelse (count :tree) <= 1 [:tree] [map.se "leaves butfirst :tree]
end
</pre>

<p><b>Пътища</b> – редица от редиците от възли от корена на дървото до листата.</p>

<pre>
to paths :tree
  if empty? :tree [output []]
  if empty? butfirst :tree [output (list :tree)]
  output map [fput first :tree ?] map.se "paths butfirst :tree
end
</pre>

<p><b>Редица от слоевете на дърво</b> – редица от редици от (стойностите на) възлите по слоеве.
Процедурата <code>forest.levels</code> (рекурсивно) образува редица от слоевете на гора;
<code>tree.levels</code>, образувайки гора от едно дърво, намира нужния резултат чрез повикване на <code>forest.levels</code>.</p>

<p>Добра храна за размисъл е защо решението по този начин, макар състоящо се от две процедури, е по-просто, отколкото ако си служим само с понятието дърво.</p>

<pre>
to tree.levels :tree
  output forest.levels (list :tree)
end

to forest.levels :ts
  if empty? :ts [output []]
  output fput map "first :ts forest.levels map.se "butfirst :ts
end
</pre>

<p>Дърво с възли и връзки както на фигурата
<pre>
                                 __a__
                                /  |  \
                               /   |   \
                              b    c    d
                             / \       /|\
                            e   f     g h i
                                |
                                j
</pre>
се представя на Logo чрез редицата <code>[a [b [e] [f [j]]] [c] [d [g] [h] [i]]]</code>.</p>

<p>За тази стойност повикванията на процедурите за обхождане дават редиците<br>
<code>        a b e f j c d g h i                               </code>префиксно<br>
<code>        e j f b c g h i d a                               </code>суфиксно<br>
<code>        e b f j a c a g d h d i                           </code>(обобщено) инфиксно<br>
<code>        e j c g h i                                       </code>листа<br>
<code>        [a b e] [a b f j] [a c] [a d g] [a d h] [a d i]   </code>пътища</br>
<code>        [a] [b c d] [e f g h i] [j]                       </code>слоеве</p>

<p>Горната схема на дърво е „нарисувана“ на ръка.
Можем ли да получаваме нещо подобно автоматично, за което и да е дърво?
Разбира се, и то по различни начини.
Показваме два от тях.</p>

<p>Съвсем проста процедура извежда съдържанието на дърво, като използва отстъпи за показване на наследяванията:</p>

<pre>
to tree.print :tr [:r]
  localmake "n ifelse empty? :r [0] [first :r]
  repeat :n [type "|    |]
  print first :tr
  foreach butfirst :tr [(tree.print ?1 (:n + 1))]
end
</pre>

<p>С известно внимание можем да преправим тази процедура така, че да извежда и линии, за да различаваме връзките възел-наследници още по-ясно:</p>

<pre>
to tree.print' :tr [:p []] [:r "false]
  foreach :p [type ?1]
  print first :tr
  if not empty? :p [make "p lput ifelse :r ["|    |] ["|\|   |] butlast :p]
  localmake "hs butfirst :tr
  if not empty? :hs [
    localmake "p' lput "|\|__ | :p
    foreach butlast :hs [(tree.print' ?1 :p')]
    (tree.print' last :hs :p' "true)
  ]
end
</pre>

<p>В двата варианта на показване дървото от по-горе изглежда така:</p>

<pre>
                     a                                         a
                         b                                     |__ b
                             e                                 |   |__ e
                             f                                 |   |__ f
                                 j                             |       |__ j
                         c                                     |__ c
                         d                                     |__ d
                             g                                     |__ g
                             h                                     |__ h
                             i                                     |__ i
</pre>

<p>(Вторият вариант е точно този, в който се показва съдържанието на директория, заедно с вложените в нея директории, с помощта на системната програма <code>tree</code> в операционните системи Linux и MS Windows.)</p>

<hr class="small">

<p>Дървото може да представя израз с аритметични и други операции с различен брой аргументи по следния начин.
Ако възел има наследници, той самият отговаря на операция, а наследниците – на нейните аргументи.
Ако възелът няма наследници, той отговаря на стойност или, което е все едно – на безаргументна операция (константа).
Така всяка операция може да има за аргументи както конкретни стойности, така и подизрази, представени чрез поддървета.</p>

<p>Обхожданията на дървото дават различни форми на запис на израза, а обхождането само на листата изброява участващите стойности – възможно с повторения, според броя на участията им.</p>

<p><b>Важен факт</b>: при префиксното и суфиксното обхождания получаваната редица еднозначно представя израза – това са така наречените <em>префиксен и суфиксен записи</em> на израза.
Префиксният е именно този, който в Logo ползваме за изразите, образувани от повиквания на процедури.</p>

<!--
<p>При инфиксното обхождане получаваната редица може да допуска повече от едно тълкуване като израз.
Това може да се поправи, като обхождането се допълни така, че съдържанието на всяко поддърво с повече от един възел се постави в скоби.</p>
-->

<!--
<p>Понеже самите операции в дърво-израз не се задават чрез редици, префиксното обхождане на такова дърво дава същия резултат, като разгледаната по-горе процедура <code>flatten</code>.</p>
-->

<p>Дърво с възли и връзки както на фигурата

<pre>
                         ________+________
                        /                 \
                       *            _______?___                 
                      / \          /       |   \                 
                     2   k      __&__      f    g
                               /     \     |    |
                              =       <    m    ~
                             / \     / \        | 
                           sin  s   p   q       *
                            |                  / \
                            a                 u   v
                   
                  
</pre>

отговаря на израза \(\,2\,k\,+\,(\)<b>АКО</b>\(\;\sin\,a=s\;\&amp;\;p&lt;q\;\,\)<b>ТО</b>\(\;f(m)\;\)<b>ИНАЧЕ</b>\(\;\,g(-u\,v))\,\),
в който умножението е представено с <code>*</code>, едноместният минус е заменен с <code>~</code>, за да го различаваме от двуаргументния <code>–</code> за изваждане, а условният избор (<b>АКО</b> <i>условие</i><b> ТО </b> <i>израз</i> <b>ИНАЧЕ</b> <i>израз</i>) е представен като триаргументна операция, означена със знака <code>?</code>.</p>

<p>Това дърво представяме чрез редицата<br>
<code>        [+ [* [2] [k]] [? [& [= [sin [a]] [s]] [< [p] [q]]] [f [m]] [g [~ [* [u] [v]]]]]]</span></code>,<br>
за която повикванията на процедурите за обхождане дават<br>
<code>        + * 2 k ? &amp; = sin a s &lt; p q f m g ~ * u v      </code>префиксна форма<br>
<code>        2 k * a sin s = p q &lt; &amp; m f u v * ~ g ? +      </code>суфиксна форма<br>
<code>        2 * k + sin a = s &amp; p &lt; q ? f m ? g ~ u * v    </code>(обобщено) инфиксна форма<br>
<code>        2 k a s p q m u v                              </code>листа</p>

<hr>

<p>Процедурите от следвашите примери пораждат чертежи на различни фигури.
Процедурите са съставени така, че центърът и ориентацията на съответната фигура са местоположението и посоката на костенурката на Logo в момента на повикването на процедурата.
Естествено изключение е полиномиалната крива, която се определя чрез редица от непосредствено зададени координати.</p>

<h2>Правилен многоъгълник</h2>

<p>Многоъгълникът се построява, като чрез движения на костенурката намираме един след друг върховете му и ги записваме в редица.
Движението от връх към връх става чрез минаване през центъра; разстоянието между центъра и връх е <code>r</code>.
Движението би могло да бъде и пряко от връх към връх, ако намерим дължината на страната, но това изисква например познаване и прилагане на синусовата теорема.</p>

<p>Подходът тук не изисква практически никакви познания по геометрия.
Спестява ни ги използването на относителността на движенията на костенурката – всяко преместване и завъртане е спрямо текущото място и посока.</p>

<p>„Най-ниската“ спрямо първоначалната посока на костенурката страна на многоъгълника е отвесна на тази посока: ако приемем посоката на костенурката за „нагоре“, страната е хоризонтална, а многоъгълникът лежи в полуравнината над нея.</p>

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="248mm" height="62mm" viewBox="-19 -11 248 62">
<g transform="matrix(1 0 0 -1 0 40)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="1.2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="-12.5,41.6506 -12.5,-1.65064 25,20 -12.5,41.6506 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(255,0,0)" fill="rgb(255,0,0)">
<g fill="none" stroke-width="1.2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="75,20 100,-5 125,20 100,45 75,20 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(34,139,34)" fill="rgb(34,139,34)">
<g fill="none" stroke-width="1.2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="187.124,-1.42918 216.401,1.13226 223.013,29.7683 197.821,44.9049 175.641,25.6238 187.124,-1.42918 "/></g></g>
</g>
</svg>
</p>

<p>Начертаването става чрез последователно посещаване на записаните координати на върховете.</p>

<pre>
to polygon :n :r
  localmake "phi 180 / :n
  localmake "vs []
  penup
  right :phi back :r
  repeat :n [queue "vs pos
             forward :r left 2 * :phi back :r]
  queue "vs pop "vs
  setpos last :vs
  pendown repeat :n [setpos pop "vs] penup
end
</pre>

<p>На много места се среща правилен многоъгълник да се построява, задавайки местоположението на единия му връх и големината на страната.
Така обаче е трудно да се предвиди къде именно, около коя точка се разполага многоъгълникът, а и изобщо колко е голям той.
Каква част от него ще се вижда на екрана и къде именно?
При една и съща страна многоъгълникът става неограничено голям с растежа на броя на страните му.
Затова много по-разумно е, както тук, да изберем като дадени центъра и радиуса на фигурата.</p>

<h2>Вписани правилни \(n\)-ъгълници</h2>

<p>Процедурата разширява горната, като вместо един многоъгълник построява <code>k</code> на брой вписани един в друг.</p>

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="92mm" height="80mm" viewBox="-46 -10 92 80">
<g transform="matrix(1 0 0 -1 0 60)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="-20,-4.64102 20,-4.64102 40,30 20,64.641 -20,64.641 -40,30 -20,-4.64102 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="-12.6083,-4.64102 23.6959,1.76038 36.3041,36.4014 12.6083,64.641 -23.6959,58.2396 -36.3041,23.5986 -12.6083,-4.64102 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="-5.89956,-3.45809 26.0258,8.16179 31.9253,41.6199 5.89956,63.4581 -26.0258,51.8382 -31.9253,18.3801 -5.89956,-3.45809 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="0,-1.31082 27.116,14.3446 27.116,45.6554 0,61.3108 -27.116,45.6554 -27.116,14.3446 0,-1.31082 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="5.01083,1.58218 27.116,20.1306 22.1051,48.5484 -5.01083,58.4178 -27.116,39.8694 -22.1051,11.4516 5.01083,1.58218 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="9.09569,5.00979 26.19,25.382 17.0943,50.3722 -9.09569,54.9902 -26.19,34.618 -17.0943,9.6278 9.09569,5.00979 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="12.2546,8.77442 24.5092,30 12.2546,51.2256 -12.2546,51.2256 -24.5092,30 -12.2546,8.77442 12.2546,8.77442 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="14.5191,12.6967 22.2446,33.9223 7.72548,51.2256 -14.5191,47.3032 -22.2446,26.0777 -7.72548,8.77442 14.5191,12.6967 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="15.9468,16.6191 19.5616,37.1198 3.61484,50.5008 -15.9468,43.3809 -19.5616,22.8802 -3.61484,9.49924 15.9468,16.6191 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="16.6148,20.4075 16.6148,39.5925 0,49.1851 -16.6148,39.5925 -16.6148,20.4075 0,10.8149 16.6148,20.4075 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="16.6148,23.9527 13.5445,41.3652 -3.07028,47.4124 -16.6148,36.0473 -13.5445,18.6348 3.07028,12.5876 16.6148,23.9527 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="16.0474,27.1704 10.4742,42.4827 -5.5732,45.3122 -16.0474,32.8296 -10.4742,17.5173 5.5732,14.6878 16.0474,27.1704 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="15.0175,30 7.50875,43.0055 -7.50875,43.0055 -15.0175,30 -7.50875,16.9945 7.50875,16.9945 15.0175,30 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="13.6299,32.4033 4.73363,43.0055 -8.89631,40.6022 -13.6299,27.5967 -4.73363,16.9945 8.89631,19.3978 13.6299,32.4033 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="11.986,34.3625 2.21492,42.5614 -9.77105,38.1989 -11.986,25.6375 -2.21492,17.4386 9.77105,21.8011 11.986,34.3625 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="10.1804,35.8776 0,41.7553 -10.1804,35.8776 -10.1804,24.1224 0,18.2447 10.1804,24.1224 10.1804,35.8776 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="8.2991,36.9638 -1.88125,40.6691 -10.1804,33.7053 -8.2991,23.0362 1.88125,19.3309 10.1804,26.2947 8.2991,36.9638 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="6.41785,37.6485 -3.41486,39.3823 -9.83271,31.7338 -6.41785,22.3515 3.41486,20.6177 9.83271,28.2662 6.41785,37.6485 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="4.60084,37.9689 -4.60084,37.9689 -9.20167,30 -4.60084,22.0311 4.60084,22.0311 9.20167,30 4.60084,37.9689 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.7" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="2.90043,37.9689 -5.45104,36.4963 -8.35147,28.5274 -2.90043,22.0311 5.45104,23.5037 8.35147,31.4726 2.90043,37.9689 "/></g></g>
</g>
</svg>
</p>

<p>Ъгълът <code>alpha</code> е този, който сключва страна на многоъгълника със съответната ѝ страна на вписания многоъгълник.
От това отношение пресмятаме коефициента на намаляване на радиуса (или страната) на многоъгълник при вписване.
Това вече, за разлика от предния пример, наистина изисква прилагане на синусовата теорема или друго подобно средство.</p>

<pre>
to polygons.nested :n :r :alpha :k
  (local "phi "p "h "vs)
  make "phi 180 / :n
  make "p pos
  make "h heading
  penup
  repeat :k ~
    [right :phi back :r
     make "vs []
     repeat :n [queue "vs pos
                forward :r left 2 * :phi back :r]
     queue "vs pop "vs
     setpos last :vs
     pendown repeat :n [setpos pop "vs] penup
     make "r (cos :phi) / (cos :alpha - :phi) * :r
     make "h :h - :alpha
     setpos :p setheading :h]
end
</pre>

<h2>Петолъчна звезда и обобщения</h2>

<p>Построяваме петолъчна звезда с еднакви лъчи по зададени радиус и полуъгъл при върха на лъча.
Различни стойности на полуъгъла водят до фигура, която не непременно е именно петолъчка, а само в по-общ смисъл е такава.</p>

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="68mm" height="66mm" viewBox="-34 40 68 66">
<g transform="matrix(1 0 0 -1 0 146)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(255,0,0)" fill="rgb(255,0,0)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="7.78924,80.721 28.5317,79.2705 12.6032,65.905 17.6336,45.7295 0,56.7482 -17.6336,45.7295 -12.6032,65.905 -28.5317,79.2705 -7.78924,80.721 0,100 "/></g></g>
</g>
</svg>
</p>

<p>За разлика от примерите с правилен многоъгълник, тук построяването като намиране на всички върхове не предхожда начертаването, а се чертае страна до всеки следващ намерен връх – всичко десет страни и върхове.
Движението от връх към връх е пряко, като най-напред намираме дължината на страна на лъч и двата ъгъла на промяна на посоката на костенурката от една страна на фигурата към следваща.</p>

<pre>
to star5 :r :phi
  localmake "beta 180 / 5
  localmake "a (sin :beta) / (sin :phi + :beta) * :r
  penup
  forward :r
  right :phi
  localmake "u 180 - 2 * :phi
  localmake "v :u - 2 * :beta
  pendown
  repeat 5 [right :u forward :a left :v forward :a]
  penup
  left :phi back :r
end
</pre>

<h2>Криви на Хилберт и Мур</h2>

<p>Кривите са всъщност рекурсивно зададени начупени линии, отворени и затворени.</p>

<p>Кривата на Хилберт от ред 0 е начупена с четири върха, свързани с три отсечки в П-образна квадратна форма.
Кривата на Хилберт от ред \(n\) се получава чрез свързване на четири различно ориентирани криви на Хилберт от ред \(n{\f-}1\).
Свързванията са отсечки с дължината на страна на крива от ред 0.</p>

<p>Кривата на Хилберт от ред \(n\) минава, без да се пресича или допира, през всички точки от квадратна мрежа със страна \(2^{n{\f+}1}{-}1\).
(Точките в такава мрежа са \(2^{n{\f+\f}2}\) на брой – по \(2^{n{\f+}1}\) върху страна на квадрата.)</p>

<p>Кривата на Мур също се получава чрез свързване на четири подходящо ориентирани криви на Хилберт от по-нисък ред и също минава през всички точки на квадратна мрежа, но е затворена начупена линия.</p>

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="249mm" height="60mm" viewBox="1 40 249 60">
<g transform="matrix(1 0 0 -1 0 140)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="6.5,66.5 6.5,73.5 13.5,73.5 13.5,66.5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="27.5,59.5 34.5,59.5 34.5,66.5 27.5,66.5 27.5,73.5 27.5,80.5 34.5,80.5 34.5,73.5 41.5,73.5 41.5,80.5 48.5,80.5 48.5,73.5 48.5,66.5 41.5,66.5 41.5,59.5 48.5,59.5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="65.5,45.5 65.5,52.5 72.5,52.5 72.5,45.5 79.5,45.5 86.5,45.5 86.5,52.5 79.5,52.5 79.5,59.5 86.5,59.5 86.5,66.5 79.5,66.5 72.5,66.5 72.5,59.5 65.5,59.5 65.5,66.5 65.5,73.5 72.5,73.5 72.5,80.5 65.5,80.5 65.5,87.5 65.5,94.5 72.5,94.5 72.5,87.5 79.5,87.5 79.5,94.5 86.5,94.5 86.5,87.5 86.5,80.5 79.5,80.5 79.5,73.5 86.5,73.5 93.5,73.5 100.5,73.5 100.5,80.5 93.5,80.5 93.5,87.5 93.5,94.5 100.5,94.5 100.5,87.5 107.5,87.5 107.5,94.5 114.5,94.5 114.5,87.5 114.5,80.5 107.5,80.5 107.5,73.5 114.5,73.5 114.5,66.5 114.5,59.5 107.5,59.5 107.5,66.5 100.5,66.5 93.5,66.5 93.5,59.5 100.5,59.5 100.5,52.5 93.5,52.5 93.5,45.5 100.5,45.5 107.5,45.5 107.5,52.5 114.5,52.5 114.5,45.5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(34,139,34)" fill="rgb(34,139,34)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="136.5,66.5 136.5,73.5 143.5,73.5 143.5,66.5 136.5,66.5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(34,139,34)" fill="rgb(34,139,34)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="164.5,59.5 157.5,59.5 157.5,66.5 164.5,66.5 164.5,73.5 157.5,73.5 157.5,80.5 164.5,80.5 171.5,80.5 178.5,80.5 178.5,73.5 171.5,73.5 171.5,66.5 178.5,66.5 178.5,59.5 171.5,59.5 164.5,59.5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(34,139,34)" fill="rgb(34,139,34)">
<g fill="none" stroke-width="0.8" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polygon points="216.5,45.5 216.5,52.5 209.5,52.5 209.5,45.5 202.5,45.5 195.5,45.5 195.5,52.5 202.5,52.5 202.5,59.5 195.5,59.5 195.5,66.5 202.5,66.5 209.5,66.5 209.5,59.5 216.5,59.5 216.5,66.5 216.5,73.5 216.5,80.5 209.5,80.5 209.5,73.5 202.5,73.5 195.5,73.5 195.5,80.5 202.5,80.5 202.5,87.5 195.5,87.5 195.5,94.5 202.5,94.5 209.5,94.5 209.5,87.5 216.5,87.5 216.5,94.5 223.5,94.5 223.5,87.5 230.5,87.5 230.5,94.5 237.5,94.5 244.5,94.5 244.5,87.5 237.5,87.5 237.5,80.5 244.5,80.5 244.5,73.5 237.5,73.5 230.5,73.5 230.5,80.5 223.5,80.5 223.5,73.5 223.5,66.5 223.5,59.5 230.5,59.5 230.5,66.5 237.5,66.5 244.5,66.5 244.5,59.5 237.5,59.5 237.5,52.5 244.5,52.5 244.5,45.5 237.5,45.5 230.5,45.5 230.5,52.5 223.5,52.5 223.5,45.5 216.5,45.5 "/></g></g>
</g>
</svg>
</p>

<p>Построяването на кривата на Хилберт става с рекурсивни повиквания на процедурата <code>hilbert</code>, като при това условните посоки „горе“, „дясно“, „долу“ и „ляво“ се променят, за да се окаже кривата от по-нисък ред ориентирана, както е нужно.</p>

<pre>
to amove :d
  case modulo (:d - :dir + 4) 4 [[[1] right 90] [[3] left 90]]
  forward :unit
  make "dir :d
end

to hilbert :n :u :r :d :l
  if :n > 0 [hilbert :n - 1 :r :u :l :d]
  amove :u
  if :n > 0 [hilbert :n - 1 :u :r :d :l]
  amove :r
  if :n > 0 [hilbert :n - 1 :u :r :d :l]
  amove :d
  if :n > 0 [hilbert :n - 1 :l :d :r :u]
end

to moore :n :u :r :d :l
  if :n > 0 [hilbert :n - 1 :l :u :r :d]
  amove :u
  if :n > 0 [hilbert :n - 1 :l :u :r :d]
  amove :r
  if :n > 0 [hilbert :n - 1 :r :d :l :u]
  amove :d
  if :n > 0 [hilbert :n - 1 :r :d :l :u]
  amove :l
end

to draw.curve :curve.type :n :unit
  localmake "dir 0
  localmake "offset :unit * ((power 2 :n) - 0.5)
  penup
  back :offset left 90
  forward (ifelse :curve.type = "hilbert [:offset] [0.5 * :unit])
  right 90
  pendown
  (invoke :curve.type :n 0 1 2 3)
end
</pre>

<p>Процедурата <code>draw.curve</code> повиква някоя от <code>hilbert</code> или <code>moore</code>, чието име ѝ се предава като стойност на параметъра <code>curve.type</code>.
Параметърът <code>n</code> задава реда на кривата, а <code>unit</code> – дължината на отсечка на крива от ред 0.
<code>draw.curve</code> осигурява центърът на кривата да бъде, където е костенурката, и ориентацията на кривата да бъде тази на костенурката.</p>

<!--
<p>Да отбележим, че променливите <code>unit</code> и <code>dir</code> принадлежат на процедурата <code>draw.curve</code> – едната като неин параметър, а другата като локално определена в процедурата.
Тези променливи обаче се използват и в процедурата <code>amove</code>.
Там те са видими, защото <code>amove</code> се повиква от <code>draw.curve</code> (косвено, чрез някоя от процедурите <code>hilbert</code> или <code>moore</code>).
Свойство на езика Logo е, че повикващата процедура дава на повикваните от нея достъп до своите локални променливи.</p>
-->

<h2>Алгебрична крива</h2>

<p>В този пример се построява алгебрична крива по зададена <em>управляваща</em> начупена линия.
Кривата отговаря на полином от степен, равна на броя на звената на начупената – първа, втора и т.н. и съответно е права, парабола или по-сложна, минаваща през двата края на начупената линия.
В зависимост от броя и взаимното разполагане на звената на начупената, кривата може да има самопресичания.</p>

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="172mm" height="63mm" viewBox="-6 -2 172 63">
<g transform="matrix(1 0 0 -1 0 59)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(169,169,169)" fill="rgb(169,169,169)">
<g fill="none" stroke-width="1" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="20,5 160,40 0,55 120,5 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="20,5 32.2638,8.22128 42.876,11.3171 51.9427,14.2793 59.5703,17.0996 65.8649,19.7697 70.9326,22.2815 74.8798,24.6266 77.8125,26.7969 79.837,28.784 81.0596,30.5798 81.5863,32.1761 81.5234,33.5645 80.9772,34.7368 80.0537,35.6848 78.8593,36.4003 77.5,36.875 76.0822,37.1007 74.7119,37.0691 73.4955,36.772 72.5391,36.2012 71.9489,35.3484 71.8311,34.2053 72.2919,32.7638 73.4375,31.0156 75.3741,28.9525 78.208,26.5662 82.0453,23.8484 86.9922,20.791 93.1549,17.3857 100.64,13.6243 109.553,9.49844 120,5 "/></g></g>
</g>
</svg>
</p>

<p>За \(n\)-звенна начупена линия, ако върховете ѝ са точките \(P_0,P_1,\dots,P_n\), точките от кривата са тези, които дава изразът</p>
\[\sum_{i=0}^n{n \choose i}(1{-\f}t)^{n-i}{\ff}t^i\ff\mathbf{P}_i \quad\mbox{за всяко}\quad{} t\in[0,1].\]
<p>За да построим графично кривата, намираме известен брой точки върху нея и чертаем образуваната от тях <em>приближаваща</em> начупена линия.
Понеже горната формула не е практична за тази цел, прилагаме следния еднообразен и прост процес.</p>

<p>По дадената управляваща начупена, да я наречем \(s_0\), намираме друга, \(s_1\), върхове на която са средните точки на звената на \(s_0\).
По същия начин от средните точки на \(s_1\) образуваме начупена \(s_2\) и т.н., докато стигнем до начупена с единствен връх.
Тъй като \(s_0\) има \(n\) звена (\(n{\f+}1\) върха), \(s_1\) ще има \(n{\f-}1\) звена, \(s_2\) ще има \(n{\f-\f}2\) и т.н.
Последната начупена – тази с единствен връх – е \(s_n\), а този единствен връх е точка от построяваната крива.</p>

<p>Освен това <em>началните</em> точки на \(s_0,s_1,\dots,s_n\) и <em>крайните</em> точки на \(s_n,s_{n-1},\dots,s_0\), взети в този ред, образуват начупени от по \(n\) звена, които са управляващи за съединените в намерената точка \(s_n\) половини от кривата, точно както \(s_0\) е управляваща за цялата крива.</p>

<p>Използвайки намерените управляващи начупени за половините от кривата, по точно същия начин намираме управляващи начупени за техните половини, заедно с по една точка върху всяка от тях.
Като извършим такова подразделяне известен брой пъти, намерените точки върху кривата образуват търсената приближаваща начупена.</p>

<p><span style="color:blue;font-weight:bold">Забележително е, че построяването на алгебрична крива от която и да е степен се свежда до единствено геометрично (или алгебрично), крайно просто действие: намиране на средна точка на две дадени!</span></p>

<!--
\(f(P_0,P_1,\dots,P_n;t)=(1-t)\ff{}f(P_0,P_1,\dots,P_{n-1};t)+t\fff{}f(P_1,P_2,\dots,P_n;t)\)
-->

<!--
За точките
  P₀
  (P₀+P₁)/2
  (P₀+2.P₁+P₂)/4
  (P₀+3.P₁+3.P₂+P₃)/8
  ...
  (P₀+n.P₁+···+P_n)/2ⁿ
и t ∈ [0,1] кривата е като за P₀,P₁,..., P_n и t ∈ [0,1/2].
-->

<p align="center">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="186mm" height="109mm" viewBox="-7 -7 186 109">
<g transform="matrix(1 0 0 -1 0 95)">
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,0)" fill="rgb(0,0,0)">
<g fill="none" stroke-width="2.5" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="0,10 1.24275,14.056 2.59434,17.9733 4.05224,21.7511 5.61389,25.3885 7.27671,28.8848 9.03806,32.2392 10.8953,35.4513 12.8457,38.5205 14.8866,41.4463 17.0151,44.2284 19.2286,46.8664 21.524,49.3602 23.8987,51.7095 26.3497,53.9144 28.874,55.9747 31.4688,57.8906 34.1308,59.6623 36.8573,61.2898 39.645,62.7737 42.4908,64.1141 45.3917,65.3115 48.3445,66.3666 51.3458,67.2798 54.3926,68.0518 57.4814,68.6833 60.6091,69.1753 63.7722,69.5285 66.9674,69.744 70.1912,69.8227 73.4403,69.7658 76.711,69.5745 80,69.25 83.3036,68.7937 86.6183,68.207 89.9404,67.4913 93.2662,66.6483 96.5922,65.6795 99.9145,64.5867 103.229,63.3716 106.533,62.0361 109.822,60.5822 113.092,59.0118 116.339,57.3271 119.559,55.5301 122.749,53.6231 125.904,51.6084 129.02,49.4885 132.094,47.2656 135.12,44.9424 138.096,42.5215 141.017,40.0056 143.878,37.3973 146.675,34.6995 149.405,31.9151 152.062,29.0472 154.643,26.0986 157.142,23.0726 159.557,19.9724 161.882,16.8012 164.112,13.5623 166.244,10.2592 168.272,6.89544 170.192,3.47448 172,0 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="0,10 19,76 76,95 144,56 172,0 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(255,165,0)" fill="rgb(255,165,0)">
<g fill="none" stroke-width="2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="9.5,43 47.5,85.5 110,75.5 158,28 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(34,139,34)" fill="rgb(34,139,34)">
<g fill="none" stroke-width="2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="28.5,64.25 78.75,80.5 134,51.75 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(0,0,255)" fill="rgb(0,0,255)">
<g fill="none" stroke-width="2" stroke-dasharray="none" stroke-linecap="round" stroke-linejoin="round">
<polyline points="53.625,72.375 106.375,66.125 "/></g></g>
<g transform="translate(0,0) scale(1,1) translate(0,0) rotate(0) scale(1,1)" stroke="rgb(255,165,0)" fill="rgb(255,165,0)">
<g stroke="none" fill-rule="evenodd">
<circle cx="80" cy="69.25" r="1.2"/></g></g>
</g>
</svg>
</p>

<p>В показаната по-долу програмна реализация на описания процес основна е процедурата <code>curve</code>, която по зададената начупена <code>ps</code> извършва <code>n</code>-кратно подразделяне, съединявайки получените за съответните участъци приближаващи кривата начупени в една такава начупена, която се дава като резултат от <code>curve</code>.
Процедурата <code>midpolyline</code> по зададена като неин аргумент управляваща начупена линия построява начупената от средните точки на звената ѝ.
Това тя прави чрез успоредно действие върху два екземпляра от дадената начупена – един без последния и един без първия ѝ връх.
Всички начупени в процеса на подразделяне на \(P_0,P_1,\dots,P_n\) се получават чрез <code>midpolyline</code>.
Процедурата <code>midpoint</code> намира средната точка на кои да е две дадени.</p>

<pre>
to curve :ps :n
  output ifelse :n = 0 ~
           [list first :ps last :ps] ~
           [localmake "pss (list :ps)
            repeat (count :ps) - 1 [queue "pss midpolyline last :pss]
            sentence curve map "first :pss :n - 1 ~
                     butfirst curve reverse map "last :pss :n - 1]
end

to midpolyline :ps
  output (map "midpoint (butlast :ps) (butfirst :ps))
end

to midpoint :a :b
  output list ((first :a) + (first :b)) / 2 ((last :a) + (last :b)) / 2
end
</pre>

<h2>Заключителни бележки</h2>

<p>Logo е един от много малкото на брой езици, създадени за обучение по програмиране.
Възрастта му (повече от половин век) сама по себе си не е причина да не бъде използван и днес за същата цел.</p>

<p>От друга страна, оказалият се устойчив уклон да се хиперболизира рисуването за сметка на всички други възможни дейности с езика, както и съсредоточаването само върху най-малките ученици е, според мен, голяма грешка.
Редица понятия, абстракции, структури и похвати с най-голяма важност в информатиката и програмирането остават напълно без внимание.
<span style="color:blue;font-weight:bold">Така се пропуска възможността знанията, мисленето и културата, които образованието би трябвало да развие, да изпитат благотворното влияние на идеите на информатиката.</span></p>

<p>Дори собствено графично-геометричните възможности на Logo са по-скоро примитивни, отколкото съответни на съвременните възможности и потребности.
Това ограничава възможностите за адекватно изразяване на идеи дори при графичната употреба на езика.</p>

<p>Ползотворно е подходът и съдържанието на преподаването чрез Logo да бъдат осмислени наново от гледна точка на потребностите от ценни, разнообразни, задълбочени и перспективни знания по информатика.
Това налага и да се осъвремени представата за действително стойностните черти на езика и това как те възможно най-добре да бъдат използвани, а и усъвършенствани.</p>

<p>Самият език се нуждае от осъвременяване в духа на казаното по-горе.
Ценните черти на езика могат да бъдат доразвити, а липсващите, но необходими свойства да бъдат хармонично и пестеливо добавени към езика.
Тъй като Logo тъй или инак няма стандартно определение, без съображения за „съвместиност с по-ранни варианти“ могат също да се поправят или направят по-удобни за употреба отделни елементи на езика.</p>

<p>От осъвременяване се нуждаят и реализациите на Logo.
Например, има много място за подобряване на времевата ефективност и за осигуряване на привлекателен интерфейс за потребителя.</p>

<p>Дадените тук примери и бележки имат за цел да илюстрират важни понятия, похвати и структури в информатиката и програмирането: рекурсия, процедури с аргументи процедури, безименни процедури и др. 
Сравнително подробно са представени особено важните структури редица и дърво.
Програмите са малки по обем, но решават теоретично и практически съдържателни задачи.</p>

<p>Всички засегнати теми имат богат потенциал за по-нататъшно експериментиране, изследване и разработване на алгоритми.</p>

<p>&nbsp;<br><br><br></p>

</body>
</html>
