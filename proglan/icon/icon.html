<html>
<head>
<title>Icon – кратки сведения</title>
<meta content="text/html" charset="utf-8" http-equiv="Content-Type">
<style type="text/css">
body {
  margin-top: 0%;
  margin-left: 15%; 
  margin-right: 15%;
  font-size: 14pt;
  text-align: left;
}
h2 {
  font-size: 18pt;
  font-weight:bold;
  border-radius:.3em;
  background-color:lightgrey;
  text-align:left;
  hyphens: none;
  margin-top:2em;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
}
h3 {
  font-size: 16pt;
  font-weight:bold;
  text-align:left;
  hyphens: none;
}
p {
  margin-top:.4em;
  margin-bottom:0em;
  text-indent:2em;
}
code,pre {
  font-family:Ubuntu Mono,Consolas,monospace;
}
code {
  font-size: 16pt;
  font-weight:bold;
  text-decoration:none;
}
pre {
  font-size: 14pt;
  padding-left:0.5em;
  padding-top:0.4em;
  padding-bottom:0.6em;
  margin-top:.4em;
  margin-bottom:.2em;
}
</style>
</head>
<body>
<h2>Компилиране и изпълняване на програми на Icon в конзолата на MS Windows</h2>

<ul>
<li>Посетете с браузър <code>https://www2.cs.arizona.edu/icon/ftp/binaries/old/msdos32/iconcns</code> и изтеглете оттам двата файла с разширение <code>.exe</code> на името: <code>icont.exe</code> и <code>iconx.exe</code>.</li>
<li>Образувайте своя работна директория за Icon, например <code>d:\icon-work</code>.<br>
Поставете в нея файловете <code>icont.exe</code> и <code>iconx.exe</code>.</li>
<li>В конзолен прозорец направете работната директория текуща.<br>
Например изпълнете командата <code>cmd</code> на о.с. – тя ще създаде конзолен прозорец – и тогава напишете и изпълнете в него командата<br>
<code>    cd /d d:\icon-work</code>.</li>
<li>Нека в работната директория имаме файл, например <code>prog.icn</code>, с текст на програма на Icon.<br>
(Разширението <code>.icn</code> на името е обичайното за програми на Icon.)<br>
За да компилирате програмата, напишете на командния ред<br>
<code>    icont prog</code>.<br>
Ако компилирането е успешно, в същата директория ще се появи файл <code>prog.exe</code> (със същото като на програмата име и разширение <code>.exe</code>.)<br>
Убедете се в това например като изпълните командата <code>dir</code> в конзолата.</li>
<li>За да изпълните компилирана програма на Icon, например <code>prog.exe</code>, напишете на командния ред в конзолата<br>
<code>    iconx prog.exe</code>.<br>
(Полученият от компилирането файл не е самостоятелно изпълнима програма, а се изпълнява именно по този начин, като файлът <code>iconx.exe</code> присъства в същата директория, за което се погрижихме.)</li>
</ul>

<h2>Операции, вградени процедури и команди в езика Icon</h2>

<pre>
общи операции
-------------
x === y                  сравняване за равенство на какви да е стойности; успява, ако x и y са еднотипни и при това са
                         или равни прости стойности, или една и съща съставна стойност

x ~=== y                 обратното на === сравнение

x := y                   присвояване

x :=: y                  размяна на стойностите на x и y; стойността е тази на x след размяната

x <- y                   условно присвояване

x <-> y                  условна размяна

\ x                      x, ако стойността му не е &amp;null, в противен случай неуспех; резултатът е променлива, ако x е такава

/ x                      x, ако стойността му е &amp;null, в противен случай неуспех; резултатът е променлива, ако x е такава

type(x)                  низ, представящ типа на x

copy(x)                  ако x е съставна стойност – равна на нея друга стойност, иначе самото x



избор
-----
if e₀ then e₁ [ else e₂ ]                 case e of {
                                            e₀₁ : e₁
                                            ...
                                          [ default : e₀₀ ]
                                          }


у-връзки
--------
e₁ &amp; e₂                  „и“ по успех

e₁ | e₂                  „или“ по успех

not e                    обръщане на успех/неуспех (&amp;null при успех)


генератори
----------
e₁ to e₂ [ by e₃ ]       аритметична прогресия с начало e₁, гранична стойност e₂ и стъпка e₃ (подразбира се 1)

seq([i[,j]])             безкрайна аритметична прогресия с начало i и стъпка j; i и j са цели числа, подразбира се 1 за всяко
                                                      
| e                      поражда докато e успява
                                                          
e \ i                    поражда ≤ i стойности
                                                          
! e                      поражда ел-те на стр-на стойност


повтаряне
---------
repeat e                 „винаги“

while e₀ [ do e₁ ]       докато e₀ е успешно

until e₀ [ do e₁ ]       докато e₀ е неуспешно

every g [ do e ]         за всяка стойност от g

next                     следващо повтаряне на текущия repeat, while, until или every

break [ e ]              напускане на текущия repeat, while, until или every; e може да е вкл. next, break и т.н.


процедури и съпрограми
----------------------
procedure име(параметри) определяне; процедурите не могат да се влагат и всички са глобални
  ...
end

x(а₁,а₂,…)               ако x е процедура или функция, повикване с посочените аргументи; x може да е име или другояче
                         получена процедурна стойност; ако x е цяло число, пресмята се изразът с този пореден номер;
                         прилага се и броенето назад; ако изразът е променлива, и резултатът е такъв

x ! y                    ако x е процедура или функция, повикване с аргументи от списъка y; x може да е име или другояче
                         получена процедурна стойност; ако x е цяло число, дава се стойността на члена на списъка y с този
                         пореден номер; прилага се и броенето назад; ако изразът е променлива, и резултатът е такъв


return [ e ]             завършва с успех (и стойност)

fail                     подразбира се при завършване на процедура!

suspend [x [ do … ]]     съпрограмно връщане на управлението към повикващия, предавайки поредната стойност на генератора x;
                         при възобновяване на изпълнението на текущия процедурен екземпляр частта след do се пресмята преди
                         пресмятането на x за пораждане на следваща стойност; за x се подразбира &amp;null

proc(s[,i])              процедурата, функцията или операцията с име s; i = 1, 2, 3 избира съответно едноместна, двуместна
                         и триместна операция, а i = 0 – вградената функция с име s, дори ако съответното глобално име е
                         получило друга стойност; подразбира се 1

args(p)                  броят параметри на процедурата p; ако той е променлив, дава се отрицателна стойност


списъци (масиви, опашки, стекове, декове)
-----------------------------------------
list([n[,x]])            списък с n члена, равни на x; подразбира се n = 0 и x = &amp;null

[x,y,…]                  списък от посочените членове

x[i]                     член

i ! x                    член

x[i:j]                   изрезка
x[i+:j]                  s[i:i+j]
x[i-:j]                  s[i:i-j]

* x                      размер

? x                      случайно избран член

! x                      изброява x

x ||| y                  слепване

push(x)                  добавяне към началото

get(x) ≡ pop(x)          извличане от началото

put(x)                   добавяне към края

pull(x)                  извличане от края

sort(x[,i])              подреждане, вкл. на разнотипни стойности, по стойността на полетата с индекс i на членовете;
                         подразбира се i = 1


низове
------
"…"                      низ с посоченото съдържание

s[i]                     член

i ! s                    член

s[i:j]                   изрезка
s[i+:j]                  s[i:i+j]
s[i-:j]                  s[i:i-j]

* s                      размер

? s                      случайно избран член

! s                      изброява s

x || y                   слепване

<< <<= >>= >> == ~==     лексикографско сравняване

left(x,n[,y])            низ с дължина n, в който x е отляво, а след него е допълнено отдясно наляво с y

right(x,n[,y])           низ с дължина n, в който x е отдясно, а пред него е допълнено отляво надясно с y

center(x,n[,y])          низ с дължина n, в който x е в средата или малко вляво, а пред и след него е допълнено с y
                         съответно както при right и left

char(n)                  низ с дължина 1 по зададен ASCII код n

ord(s)                   ASCII кода на литерата – единствен член на низа s

repl(s,n)                низ от n повторения на s

reverse(s)               низът, обратен на s

map(s[,s₁,s₂])           низ, получен от s чрез замяна на всяка литера от cset(s)**cset(s₁) със съответната ѝ
                         по място в s₂;  подразбира се замяна на главни с малки букви от латиницата

find(s₁,s₂[,i,j])        редицата от индекси в s₂, които са начало на подниз в рамките на s₂[i:j], равен на s₁

match(s₁,s₂[,i,j])       индексът в s₂ след префикса на s₂[i:j], равен на s₁

any(cs,s[,i,j])          индекс в s на първата литера от множеството cs в рамките на s[i:j];
                         неуспех, ако s[i] не е от cs

many(cs,s[,i,j])         индекс в s на първата литера след тези от множеството cs в рамките на s[i:j];
                         неуспех, ако s[i] не е от cs

upto(cs,s[,i,j])         редицата от индекси в s в рамките на s[i:j], която предхожда
                         първата литера от cs, намираща се в същия отрязък

tab(i)                   дава &amp;subject[&amp;pos:i] и изпълнява &amp;pos := i

move(i)                  дава &amp;subject[&amp;pos:&amp;pos+i] и изпълнява &amp;pos +:= i

trim(s,cs)               низ от съдържанието на s без остатъчните му членове, които са членове и на множеството cs

bal(cs₁,cs₂,cs₃,s[,i,j]) редица от индекси в s на литери в рамките на s[i:j], които са от cs₁ и след които литерите в s[i:j]
                         са уравновесени по отношение на съответствието между cs₂ и cs₃; подразбира се cs₁ = &amp;cset, cs₂ = '('
                         и cs₃ = ')'; употребява се основно за намиране на съответна скоба, включително при влагане

=s                       tab(match(s))


сканиране
---------
s ? x                    пресмятане на x в контекста на низа s – служи за претърсване на низ; когато са част от израза
                         x в операция ?, за множество вградени функции върху низове основният аргумент низ се подразбира
                         да е s; при завършване на операция ?, вложена в друга такава, се възстановяват стойностите на
                         &amp;subject и &amp;pos

s ?:= x                  като s ? x, като накрая резултатът се присвоява на s

&amp;subject                 променлива със стойност претърсваният при пресмятане на израз s?x низ

&amp;pos                     променлива със стойност текущата позиция в &amp;subject при пресмятане на израз s?x
                         промените на &amp;pos под действието на разните функции се отменят при неуспех – използва
                         се за възвратно програмиране

pos(i)                   стойността на &amp;pos, ако |i| = &amp;pos (в противен случай неуспех)


таблици
-------
table([x])               таблица с подразбираща се стойност x (за която се подразбира &amp;null)

t[k]                     член

* t                      размер

? t                      случайно избран член

! t                      изброява t

member(t,k)              k при успех (t има член с ключ k)

insert(t,k,x)            добавя към t стойност x с ключ k, дава t

delete(t,x)              премахва x, дава t

key(t)                   поражда ключовете от t

sort(x[,i])              списък от двойките (списъци от по два члена) ключ-стойност на таблицата x,
                         подредени по ключа (при i = 1) или по стойността (при i = 2); подразбира се i = 1


множества
---------
set(x)                   множество от членовете на списъка x

x ** y                   сечение

x ++ y                   обединение

x -- y                   разлика

* x                      размер

? x                      случайно избран член

! x                      изброява x

member(s,x)              x при успех (x ∈ s)

insert(s,x)              добавя x, дава s

delete(s,x)              премахва x, дава s

sort(x[,i])              списък от членовете на множеството x, подредени, вкл. при разнотипни стойности,
                         по стойността на полетата с индекс i на членовете; подразбира се i = 1


литерни множества
-----------------
cset(x)                  литерно множество от (литерите на) x

'…'                      литерно множество от посочени членове

* x                      размер

? x                      случайно избран член

x ** y                   сечение

x ++ y                   обединение

x -- y                   разлика

~ x                      допълнение 

&amp;cset                    всички литери

&amp;ascii                   128-те литери от множеството ASCII

&amp;digits                  десетте цифри

&amp;letters                 52-те букви от латиницата

&amp;lcase                   малките букви от латиницата

&amp;ucase                   главните букви от латиницата


смеси
-----
record x(y₁,y₂,…)        определение на смес („запис“) с име x и имена на полета изброените в скоби; допуска се само глобално

x(a₁,a₂,…)               образуване на стойност смес от смесения тип с име x и стойности на полетата, както са изброени

x.y                      цитиране на полето y на сместа x

x["y"]                   същото като x.y

x[i]                     цитиране на полето с пореден номер i (цяло число с право или обратно броене)

* x                      брой на полетата на x

? x                      стойността на случайно избрано поле на x

! x                      изброява стойностите на полетата на x


съизрази
--------
create x                 съизраз от израза x

@ x                      резултатът от пресмятането на съизраза x

y @ x                    резултатът от пресмятането на съизраза x с аргумент y (@x от по-горе е съкращение на &amp;null @ x)

^ x                      подновен съизраз от x

* x                      брой породени стойности

&amp;current                 текущо пресмятаният съизраз

&amp;source                  съизразът, повикал текущия съизраз; например @&amp;source е като suspend в процедура

&amp;main                    съизраз, пресмятащ функцията main – все едно, че е породен с @(create main())


вход и изход
------------
read([f])                ред текст, ако има такъв, от файла f; подразбира се &amp;input – стандартният вход

reads([f[,n]])           низ от n или колкото остават литери от файла f; край на ред не се различава от останалите литери;
                         подразбира се f = &amp;input, n = 1

write(а₁,а₂,…)           записване в един или повече файлове с поставяне на литерата край на ред накрая или при преминаване
                         към друг файл; по начало се записва в &amp;output – стандартния изход; ако текущият аргумент е низ,
                         записва се в текущия файл, а ако е файл, той се избира за такъв, в който се записва по-нататък

writes(а₁,а₂,…)          като write(а₁,а₂,…), но без добавяне на литерата край на ред
</pre>
</body>
</html>

<!--
 _   _       _   _
((___))     ((___))
< O O >     < O O >
 \   /       \   /
 (' ')       ('_')
   U            


   __@         __o
 _`\<,_      _`\<,_
( )/ ( )    ( )/ ( )
-->
